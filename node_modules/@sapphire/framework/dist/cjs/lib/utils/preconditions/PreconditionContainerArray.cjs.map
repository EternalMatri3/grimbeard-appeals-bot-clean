{"version":3,"sources":["../../../../../src/lib/utils/preconditions/PreconditionContainerArray.ts"],"names":["PreconditionRunMode","PreconditionRunCondition","PreconditionContainerSingle","Collection","PreconditionConditionAnd","PreconditionConditionOr"],"mappings":"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","file":"PreconditionContainerArray.cjs","sourcesContent":["import { Collection, type ChatInputCommandInteraction, type ContextMenuCommandInteraction, type Message } from 'discord.js';\nimport type { PreconditionContext, PreconditionKeys, SimplePreconditionKeys } from '../../structures/Precondition';\nimport type { ChatInputCommand, ContextMenuCommand, MessageCommand } from '../../types/CommandTypes';\nimport type { IPreconditionContainer, PreconditionContainerReturn } from './IPreconditionContainer';\nimport {\n\tPreconditionContainerSingle,\n\ttype PreconditionSingleResolvable,\n\ttype PreconditionSingleResolvableDetails,\n\ttype SimplePreconditionSingleResolvableDetails\n} from './PreconditionContainerSingle';\nimport type { IPreconditionCondition } from './conditions/IPreconditionCondition';\nimport { PreconditionConditionAnd } from './conditions/PreconditionConditionAnd';\nimport { PreconditionConditionOr } from './conditions/PreconditionConditionOr';\n\n/**\n * The run mode for a {@link PreconditionContainerArray}.\n * @since 1.0.0\n */\nexport enum PreconditionRunMode {\n\t/**\n\t * The entries are run sequentially, this is the default behaviour and can be slow when doing long asynchronous\n\t * tasks, but is performance savvy.\n\t * @since 1.0.0\n\t */\n\tSequential,\n\n\t/**\n\t * All entries are run in parallel using `Promise.all`, then the results are processed after all of them have\n\t * completed.\n\t * @since 1.0.0\n\t */\n\tParallel\n}\n\n/**\n * The condition for a {@link PreconditionContainerArray}.\n */\nexport enum PreconditionRunCondition {\n\t/**\n\t * Defines a condition where all the entries must pass. This uses {@link PreconditionConditionAnd}.\n\t * @since 1.0.0\n\t */\n\tAnd,\n\n\t/**\n\t * Defines a condition where at least one entry must pass. This uses {@link PreconditionConditionOr}.\n\t * @since 1.0.0\n\t */\n\tOr\n}\n\n/**\n * Defines the detailed options for the {@link PreconditionContainerArray}, where both the {@link PreconditionRunMode} and the\n * entries can be defined.\n * @since 1.0.0\n */\nexport interface PreconditionArrayResolvableDetails {\n\t/**\n\t * The data that will be used to resolve {@link IPreconditionContainer} dependent of this one.\n\t * @since 1.0.0\n\t */\n\tentries: readonly PreconditionEntryResolvable[];\n\n\t/**\n\t * The mode the {@link PreconditionContainerArray} will run.\n\t * @since 1.0.0\n\t */\n\tmode: PreconditionRunMode;\n}\n\n/**\n * Defines the data accepted by {@link PreconditionContainerArray}'s constructor.\n * @since 1.0.0\n */\nexport type PreconditionArrayResolvable = readonly PreconditionEntryResolvable[] | PreconditionArrayResolvableDetails;\n\n/**\n * Defines the data accepted for each entry of the array.\n * @since 1.0.0\n * @seealso {@link PreconditionArrayResolvable}\n * @seealso {@link PreconditionArrayResolvableDetails.entries}\n */\nexport type PreconditionEntryResolvable = PreconditionSingleResolvable | PreconditionArrayResolvable;\n\nfunction isSingle(entry: PreconditionEntryResolvable): entry is PreconditionSingleResolvable {\n\treturn typeof entry === 'string' || Reflect.has(entry, 'name');\n}\n\n/**\n * An {@link IPreconditionContainer} that defines an array of multiple {@link IPreconditionContainer}s.\n *\n * By default, array containers run either of two conditions: AND and OR ({@link PreconditionRunCondition}), the top level\n * will always default to AND, where the nested one flips the logic (OR, then children arrays are AND, then OR...).\n *\n * This allows `['Connect', ['Moderator', ['DJ', 'SongAuthor']]]` to become a thrice-nested precondition container, where:\n * - Level 1: [Single(Connect), Array] runs AND, both containers must return a successful value.\n * - Level 2: [Single(Moderator), Array] runs OR, either container must return a successful value.\n * - Level 3: [Single(DJ), Single(SongAuthor)] runs AND, both containers must return a successful value.\n *\n * In other words, it is identical to doing:\n * ```typescript\n * Connect && (Moderator || (DJ && SongAuthor));\n * ```\n * @remark More advanced logic can be accomplished by adding more {@link IPreconditionCondition}s (e.g. other operators),\n * see {@link PreconditionContainerArray.conditions} for more information.\n * @since 1.0.0\n */\nexport class PreconditionContainerArray implements IPreconditionContainer {\n\t/**\n\t * The mode at which this precondition will run.\n\t * @since 1.0.0\n\t */\n\tpublic readonly mode: PreconditionRunMode;\n\n\t/**\n\t * The {@link IPreconditionContainer}s the array holds.\n\t * @since 1.0.0\n\t */\n\tpublic readonly entries: IPreconditionContainer[];\n\n\t/**\n\t * The {@link PreconditionRunCondition} that defines how entries must be handled.\n\t * @since 1.0.0\n\t */\n\tpublic readonly runCondition: PreconditionRunCondition;\n\n\tpublic constructor(data: PreconditionArrayResolvable = [], parent: PreconditionContainerArray | null = null) {\n\t\tthis.entries = [];\n\t\tthis.runCondition = parent?.runCondition === PreconditionRunCondition.And ? PreconditionRunCondition.Or : PreconditionRunCondition.And;\n\n\t\tif (Array.isArray(data)) {\n\t\t\tconst casted = data as readonly PreconditionEntryResolvable[];\n\n\t\t\tthis.mode = parent?.mode ?? PreconditionRunMode.Sequential;\n\t\t\tthis.parse(casted);\n\t\t} else {\n\t\t\tconst casted = data as PreconditionArrayResolvableDetails;\n\n\t\t\tthis.mode = casted.mode;\n\t\t\tthis.parse(casted.entries);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a new entry to the array.\n\t * @since 1.0.0\n\t * @param entry The value to add to the entries.\n\t */\n\tpublic add(entry: IPreconditionContainer): this {\n\t\tthis.entries.push(entry);\n\t\treturn this;\n\t}\n\n\tpublic append(keyOrEntries: SimplePreconditionSingleResolvableDetails | SimplePreconditionKeys | PreconditionContainerArray): this;\n\tpublic append<K extends PreconditionKeys>(entry: PreconditionSingleResolvableDetails<K>): this;\n\tpublic append(entry: PreconditionContainerArray | PreconditionSingleResolvable): this {\n\t\tthis.entries.push(entry instanceof PreconditionContainerArray ? entry : new PreconditionContainerSingle(entry));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Runs the container.\n\t * @since 1.0.0\n\t * @param message The message that ran this precondition.\n\t * @param command The command the message invoked.\n\t * @param context The context for the message command precondition.\n\t */\n\tpublic messageRun(message: Message, command: MessageCommand, context: PreconditionContext = {}): PreconditionContainerReturn {\n\t\treturn this.mode === PreconditionRunMode.Sequential\n\t\t\t? this.condition.messageSequential(message, command, this.entries, context)\n\t\t\t: this.condition.messageParallel(message, command, this.entries, context);\n\t}\n\n\t/**\n\t * Runs the container.\n\t * @since 3.0.0\n\t * @param interaction The interaction that ran this precondition.\n\t * @param command The command the interaction invoked.\n\t * @param context The context for the chat input precondition.\n\t */\n\tpublic chatInputRun(\n\t\tinteraction: ChatInputCommandInteraction,\n\t\tcommand: ChatInputCommand,\n\t\tcontext: PreconditionContext = {}\n\t): PreconditionContainerReturn {\n\t\treturn this.mode === PreconditionRunMode.Sequential\n\t\t\t? this.condition.chatInputSequential(interaction, command, this.entries, context)\n\t\t\t: this.condition.chatInputParallel(interaction, command, this.entries, context);\n\t}\n\n\t/**\n\t * Runs the container.\n\t * @since 3.0.0\n\t * @param interaction The interaction that ran this precondition.\n\t * @param command The command the interaction invoked.\n\t * @param context  The context for the context menu precondition.\n\t */\n\tpublic contextMenuRun(\n\t\tinteraction: ContextMenuCommandInteraction,\n\t\tcommand: ContextMenuCommand,\n\t\tcontext: PreconditionContext = {}\n\t): PreconditionContainerReturn {\n\t\treturn this.mode === PreconditionRunMode.Sequential\n\t\t\t? this.condition.contextMenuSequential(interaction, command, this.entries, context)\n\t\t\t: this.condition.contextMenuParallel(interaction, command, this.entries, context);\n\t}\n\n\t/**\n\t * Parses the precondition entry resolvables, and adds them to the entries.\n\t * @since 1.0.0\n\t * @param entries The entries to parse.\n\t */\n\tprotected parse(entries: Iterable<PreconditionEntryResolvable>): this {\n\t\tfor (const entry of entries) {\n\t\t\tthis.add(\n\t\t\t\tisSingle(entry) //\n\t\t\t\t\t? new PreconditionContainerSingle(entry)\n\t\t\t\t\t: new PreconditionContainerArray(entry, this)\n\t\t\t);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Retrieves a condition from {@link PreconditionContainerArray.conditions}, assuming existence.\n\t * @since 1.0.0\n\t */\n\tprotected get condition(): IPreconditionCondition {\n\t\treturn PreconditionContainerArray.conditions.get(this.runCondition)!;\n\t}\n\n\t/**\n\t * The preconditions to be run. Extra ones can be added by augmenting {@link PreconditionRunCondition} and then\n\t * inserting {@link IPreconditionCondition}s.\n\t * @since 1.0.0\n\t * @example\n\t * ```typescript\n\t * // Adding more kinds of conditions\n\t *\n\t * // Set the new condition:\n\t * PreconditionContainerArray.conditions.set(2, PreconditionConditionRandom);\n\t *\n\t * // Augment Sapphire to add the new condition, in case of a JavaScript\n\t * // project, this can be moved to an `Augments.d.ts` (or any other name)\n\t * // file somewhere:\n\t * declare module '@sapphire/framework' {\n\t *   export enum PreconditionRunCondition {\n\t *     Random = 2\n\t *   }\n\t * }\n\t * ```\n\t */\n\tpublic static readonly conditions = new Collection<PreconditionRunCondition, IPreconditionCondition>([\n\t\t[PreconditionRunCondition.And, PreconditionConditionAnd],\n\t\t[PreconditionRunCondition.Or, PreconditionConditionOr]\n\t]);\n}\n"]}