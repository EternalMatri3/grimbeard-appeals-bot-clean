{"version":3,"sources":["../../../../../../src/lib/utils/preconditions/conditions/PreconditionConditionAnd.ts"],"names":["Result"],"mappings":";;;;;AAOO,IAAM,wBAAA,GAAmD;AAAA,EAC/D,MAAM,iBAAA,CAAkB,OAAA,EAAS,OAAA,EAAS,SAAS,OAAA,EAAS;AAC3D,IAAA,KAAA,MAAW,SAAS,OAAA,EAAS;AAC5B,MAAA,MAAM,SAAS,MAAM,KAAA,CAAM,UAAA,CAAW,OAAA,EAAS,SAAS,OAAO,CAAA;AAC/D,MAAA,IAAI,MAAA,CAAO,KAAA,EAAM,EAAG,OAAO,MAAA;AAAA,IAC5B;AAEA,IAAA,OAAOA,cAAO,EAAA,EAAG;AAAA,EAClB,CAAA;AAAA,EACA,MAAM,eAAA,CAAgB,OAAA,EAAS,OAAA,EAAS,SAAS,OAAA,EAAS;AACzD,IAAA,MAAM,OAAA,GAAU,MAAM,OAAA,CAAQ,GAAA,CAAI,QAAQ,GAAA,CAAI,CAAC,KAAA,KAAU,KAAA,CAAM,UAAA,CAAW,OAAA,EAAS,OAAA,EAAS,OAAO,CAAC,CAAC,CAAA;AAGrG,IAAA,OAAO,OAAA,CAAQ,KAAK,CAAC,GAAA,KAAQ,IAAI,KAAA,EAAO,CAAA,IAAKA,aAAA,CAAO,EAAA,EAAG;AAAA,EACxD,CAAA;AAAA,EACA,MAAM,mBAAA,CAAoB,WAAA,EAAa,OAAA,EAAS,SAAS,OAAA,EAAS;AACjE,IAAA,KAAA,MAAW,SAAS,OAAA,EAAS;AAC5B,MAAA,MAAM,SAAS,MAAM,KAAA,CAAM,YAAA,CAAa,WAAA,EAAa,SAAS,OAAO,CAAA;AACrE,MAAA,IAAI,MAAA,CAAO,KAAA,EAAM,EAAG,OAAO,MAAA;AAAA,IAC5B;AAEA,IAAA,OAAOA,cAAO,EAAA,EAAG;AAAA,EAClB,CAAA;AAAA,EACA,MAAM,iBAAA,CAAkB,WAAA,EAAa,OAAA,EAAS,SAAS,OAAA,EAAS;AAC/D,IAAA,MAAM,OAAA,GAAU,MAAM,OAAA,CAAQ,GAAA,CAAI,QAAQ,GAAA,CAAI,CAAC,KAAA,KAAU,KAAA,CAAM,YAAA,CAAa,WAAA,EAAa,OAAA,EAAS,OAAO,CAAC,CAAC,CAAA;AAG3G,IAAA,OAAO,OAAA,CAAQ,KAAK,CAAC,GAAA,KAAQ,IAAI,KAAA,EAAO,CAAA,IAAKA,aAAA,CAAO,EAAA,EAAG;AAAA,EACxD,CAAA;AAAA,EACA,MAAM,qBAAA,CAAsB,WAAA,EAAa,OAAA,EAAS,SAAS,OAAA,EAAS;AACnE,IAAA,KAAA,MAAW,SAAS,OAAA,EAAS;AAC5B,MAAA,MAAM,SAAS,MAAM,KAAA,CAAM,cAAA,CAAe,WAAA,EAAa,SAAS,OAAO,CAAA;AACvE,MAAA,IAAI,MAAA,CAAO,KAAA,EAAM,EAAG,OAAO,MAAA;AAAA,IAC5B;AAEA,IAAA,OAAOA,cAAO,EAAA,EAAG;AAAA,EAClB,CAAA;AAAA,EACA,MAAM,mBAAA,CAAoB,WAAA,EAAa,OAAA,EAAS,SAAS,OAAA,EAAS;AACjE,IAAA,MAAM,OAAA,GAAU,MAAM,OAAA,CAAQ,GAAA,CAAI,QAAQ,GAAA,CAAI,CAAC,KAAA,KAAU,KAAA,CAAM,cAAA,CAAe,WAAA,EAAa,OAAA,EAAS,OAAO,CAAC,CAAC,CAAA;AAG7G,IAAA,OAAO,OAAA,CAAQ,KAAK,CAAC,GAAA,KAAQ,IAAI,KAAA,EAAO,CAAA,IAAKA,aAAA,CAAO,EAAA,EAAG;AAAA,EACxD;AACD","file":"PreconditionConditionAnd.cjs","sourcesContent":["import { Result } from '@sapphire/result';\nimport type { IPreconditionCondition } from './IPreconditionCondition';\n\n/**\n * An {@link IPreconditionCondition} which runs all containers similarly to doing (V0 && V1 [&& V2 [&& V3 ...]]).\n * @since 1.0.0\n */\nexport const PreconditionConditionAnd: IPreconditionCondition = {\n\tasync messageSequential(message, command, entries, context) {\n\t\tfor (const child of entries) {\n\t\t\tconst result = await child.messageRun(message, command, context);\n\t\t\tif (result.isErr()) return result;\n\t\t}\n\n\t\treturn Result.ok();\n\t},\n\tasync messageParallel(message, command, entries, context) {\n\t\tconst results = await Promise.all(entries.map((entry) => entry.messageRun(message, command, context)));\n\t\t// This is simplified compared to PreconditionContainerAny, because we're looking for the first error.\n\t\t// However, the base implementation short-circuits with the first Ok.\n\t\treturn results.find((res) => res.isErr()) ?? Result.ok();\n\t},\n\tasync chatInputSequential(interaction, command, entries, context) {\n\t\tfor (const child of entries) {\n\t\t\tconst result = await child.chatInputRun(interaction, command, context);\n\t\t\tif (result.isErr()) return result;\n\t\t}\n\n\t\treturn Result.ok();\n\t},\n\tasync chatInputParallel(interaction, command, entries, context) {\n\t\tconst results = await Promise.all(entries.map((entry) => entry.chatInputRun(interaction, command, context)));\n\t\t// This is simplified compared to PreconditionContainerAny, because we're looking for the first error.\n\t\t// However, the base implementation short-circuits with the first Ok.\n\t\treturn results.find((res) => res.isErr()) ?? Result.ok();\n\t},\n\tasync contextMenuSequential(interaction, command, entries, context) {\n\t\tfor (const child of entries) {\n\t\t\tconst result = await child.contextMenuRun(interaction, command, context);\n\t\t\tif (result.isErr()) return result;\n\t\t}\n\n\t\treturn Result.ok();\n\t},\n\tasync contextMenuParallel(interaction, command, entries, context) {\n\t\tconst results = await Promise.all(entries.map((entry) => entry.contextMenuRun(interaction, command, context)));\n\t\t// This is simplified compared to PreconditionContainerAny, because we're looking for the first error.\n\t\t// However, the base implementation short-circuits with the first Ok.\n\t\treturn results.find((res) => res.isErr()) ?? Result.ok();\n\t}\n};\n"]}