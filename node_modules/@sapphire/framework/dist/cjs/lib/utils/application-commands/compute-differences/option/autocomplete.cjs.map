{"version":3,"sources":["../../../../../../../src/lib/utils/application-commands/compute-differences/option/autocomplete.ts"],"names":["checkLocalizations"],"mappings":"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","file":"autocomplete.cjs","sourcesContent":["import type { APIApplicationCommandOptionChoice } from 'discord-api-types/v10';\nimport type { APIApplicationCommandChoosableAndAutocompletableTypes, CommandDifference } from '../_shared';\nimport { checkLocalizations } from '../localizations';\n\nexport function* handleAutocomplete({\n\tcurrentIndex,\n\texistingOption,\n\texpectedOption,\n\tkeyPath\n}: {\n\tcurrentIndex: number;\n\tkeyPath: (index: number) => string;\n\texpectedOption: APIApplicationCommandChoosableAndAutocompletableTypes;\n\texistingOption: APIApplicationCommandChoosableAndAutocompletableTypes;\n}): Generator<CommandDifference> {\n\t// 0. No autocomplete and now it should autocomplete\n\tif (!existingOption.autocomplete && expectedOption.autocomplete) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.autocomplete`,\n\t\t\texpected: 'autocomplete enabled',\n\t\t\toriginal: 'autocomplete disabled'\n\t\t};\n\t}\n\t// 1. Have autocomplete and now it shouldn't\n\telse if (existingOption.autocomplete && !expectedOption.autocomplete) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.autocomplete`,\n\t\t\texpected: 'autocomplete disabled',\n\t\t\toriginal: 'autocomplete enabled'\n\t\t};\n\t}\n\n\tif (!expectedOption.autocomplete && !existingOption.autocomplete) {\n\t\t// 0. No choices and now we have choices\n\t\tif (!existingOption.choices?.length && expectedOption.choices?.length) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.choices`,\n\t\t\t\texpected: 'choices present',\n\t\t\t\toriginal: 'no choices present'\n\t\t\t};\n\t\t}\n\t\t// 1. Have choices and now we don't\n\t\telse if (existingOption.choices?.length && !expectedOption.choices?.length) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.choices`,\n\t\t\t\texpected: 'no choices present',\n\t\t\t\toriginal: 'choices present'\n\t\t\t};\n\t\t}\n\t\t// 2. Check every choice to see differences\n\t\telse if (expectedOption.choices?.length && existingOption.choices?.length) {\n\t\t\tlet index = 0;\n\t\t\tfor (const choice of expectedOption.choices) {\n\t\t\t\tconst currentChoiceIndex = index++;\n\t\t\t\tconst existingChoice = existingOption.choices[currentChoiceIndex];\n\n\t\t\t\t// If this choice never existed, return the difference\n\t\t\t\tif (existingChoice === undefined) {\n\t\t\t\t\tyield {\n\t\t\t\t\t\tkey: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}]`,\n\t\t\t\t\t\toriginal: 'no choice present',\n\t\t\t\t\t\texpected: 'choice present'\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tif (choice.name !== existingChoice.name) {\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\tkey: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].name`,\n\t\t\t\t\t\t\toriginal: existingChoice.name,\n\t\t\t\t\t\t\texpected: choice.name\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check localized names\n\t\t\t\t\tconst originalLocalizedNames = existingChoice.name_localizations;\n\t\t\t\t\tconst expectedLocalizedNames = choice.name_localizations;\n\n\t\t\t\t\tyield* checkLocalizations({\n\t\t\t\t\t\tlocaleMapName: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].nameLocalizations`,\n\t\t\t\t\t\tlocalePresentMessage: 'localized names',\n\t\t\t\t\t\tlocaleMissingMessage: 'no localized names',\n\t\t\t\t\t\toriginalLocalizedDescriptions: originalLocalizedNames,\n\t\t\t\t\t\texpectedLocalizedDescriptions: expectedLocalizedNames\n\t\t\t\t\t});\n\n\t\t\t\t\tif (choice.value !== existingChoice.value) {\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\tkey: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].value`,\n\t\t\t\t\t\t\toriginal: String(existingChoice.value),\n\t\t\t\t\t\t\texpected: String(choice.value)\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there are more choices than the expected ones, return the difference\n\t\t\tif (index < existingOption.choices.length) {\n\t\t\t\tlet choice: APIApplicationCommandOptionChoice;\n\t\t\t\twhile ((choice = existingOption.choices[index]) !== undefined) {\n\t\t\t\t\tyield {\n\t\t\t\t\t\tkey: `existing choice at path ${keyPath(currentIndex)}.choices[${index}]`,\n\t\t\t\t\t\texpected: 'no choice present',\n\t\t\t\t\t\toriginal: `choice with name \"${choice.name}\" and value ${\n\t\t\t\t\t\t\ttypeof choice.value === 'number' ? choice.value : `\"${choice.value}\"`\n\t\t\t\t\t\t} present`\n\t\t\t\t\t};\n\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"]}