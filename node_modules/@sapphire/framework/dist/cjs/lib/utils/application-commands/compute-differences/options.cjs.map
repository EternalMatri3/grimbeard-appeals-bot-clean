{"version":3,"sources":["../../../../../../src/lib/utils/application-commands/compute-differences/options.ts"],"names":["optionTypeToPrettyName","checkOptionType","checkName","checkLocalizations","checkDescription","checkOptionRequired","subcommandTypes","ApplicationCommandOptionType","hasMinMaxValueSupport","handleMinMaxValueOptions","hasChoicesAndAutocompleteSupport","handleAutocomplete","hasMinMaxLengthSupport","handleMinMaxLengthOptions","hasChannelTypesSupport","checkChannelTypes"],"mappings":"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","file":"options.cjs","sourcesContent":["import {\n\tApplicationCommandOptionType,\n\ttype APIApplicationCommandBasicOption,\n\ttype APIApplicationCommandChannelOption,\n\ttype APIApplicationCommandOption\n} from 'discord-api-types/v10';\nimport {\n\thasChannelTypesSupport,\n\thasChoicesAndAutocompleteSupport,\n\thasMinMaxLengthSupport,\n\thasMinMaxValueSupport,\n\toptionTypeToPrettyName,\n\tsubcommandTypes,\n\ttype APIApplicationCommandChoosableAndAutocompletableTypes,\n\ttype APIApplicationCommandMinAndMaxValueTypes,\n\ttype APIApplicationCommandMinMaxLengthTypes,\n\ttype APIApplicationCommandSubcommandTypes,\n\ttype CommandDifference\n} from './_shared';\nimport { checkDescription } from './description';\nimport { checkLocalizations } from './localizations';\nimport { checkName } from './name';\nimport { handleAutocomplete } from './option/autocomplete';\nimport { checkChannelTypes } from './option/channelTypes';\nimport { handleMinMaxLengthOptions } from './option/minMaxLength';\nimport { handleMinMaxValueOptions } from './option/minMaxValue';\nimport { checkOptionRequired } from './option/required';\nimport { checkOptionType } from './option/type';\n\nexport function* checkOptions(\n\texistingOptions?: APIApplicationCommandOption[],\n\tnewOptions?: APIApplicationCommandOption[]\n): Generator<CommandDifference> {\n\t// 0. No existing options and now we have options\n\tif (!existingOptions?.length && newOptions?.length) {\n\t\tyield {\n\t\t\tkey: 'options',\n\t\t\toriginal: 'no options present',\n\t\t\texpected: 'options present'\n\t\t};\n\t}\n\t// 1. Existing options and now we have no options\n\telse if (existingOptions?.length && !newOptions?.length) {\n\t\tyield {\n\t\t\tkey: 'options',\n\t\t\toriginal: 'options present',\n\t\t\texpected: 'no options present'\n\t\t};\n\t}\n\t// 2. Iterate over each option if we have any and see what's different\n\telse if (newOptions?.length) {\n\t\tlet index = 0;\n\t\tfor (const option of newOptions) {\n\t\t\tconst currentIndex = index++;\n\t\t\tconst existingOption = existingOptions![currentIndex];\n\t\t\tyield* reportOptionDifferences({ currentIndex, option, existingOption });\n\t\t}\n\n\t\t// If we went through less options than we previously had, report that\n\t\tif (index < existingOptions!.length) {\n\t\t\tlet option: APIApplicationCommandOption;\n\t\t\twhile ((option = existingOptions![index]) !== undefined) {\n\t\t\t\tconst expectedType =\n\t\t\t\t\toptionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;\n\n\t\t\t\tyield {\n\t\t\t\t\tkey: `existing command option at index ${index}`,\n\t\t\t\t\texpected: 'no option present',\n\t\t\t\t\toriginal: `${expectedType} with name ${option.name}`\n\t\t\t\t};\n\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction* reportOptionDifferences({\n\toption,\n\texistingOption,\n\tcurrentIndex,\n\tkeyPath = (index: number) => `options[${index}]`\n}: {\n\toption: APIApplicationCommandOption;\n\tcurrentIndex: number;\n\texistingOption?: APIApplicationCommandOption;\n\tkeyPath?: (index: number) => string;\n}): Generator<CommandDifference> {\n\t// If current option doesn't exist, report and return\n\tif (!existingOption) {\n\t\tconst expectedType = optionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;\n\n\t\tyield {\n\t\t\tkey: keyPath(currentIndex),\n\t\t\texpected: `${expectedType} with name ${option.name}`,\n\t\t\toriginal: 'no option present'\n\t\t};\n\n\t\treturn;\n\t}\n\n\t// Check type\n\tyield* checkOptionType({\n\t\tkey: `${keyPath(currentIndex)}.type`,\n\t\toriginalType: existingOption.type,\n\t\texpectedType: option.type\n\t});\n\n\t// Check name\n\tyield* checkName({\n\t\tkey: `${keyPath(currentIndex)}.name`,\n\t\toldName: existingOption.name,\n\t\tnewName: option.name\n\t});\n\n\t// Check localized names\n\tconst originalLocalizedNames = existingOption.name_localizations;\n\tconst expectedLocalizedNames = option.name_localizations;\n\n\tyield* checkLocalizations({\n\t\tlocaleMapName: `${keyPath(currentIndex)}.nameLocalizations`,\n\t\tlocalePresentMessage: 'localized names',\n\t\tlocaleMissingMessage: 'no localized names',\n\t\toriginalLocalizedDescriptions: originalLocalizedNames,\n\t\texpectedLocalizedDescriptions: expectedLocalizedNames\n\t});\n\n\t// Check description\n\tyield* checkDescription({\n\t\tkey: `${keyPath(currentIndex)}.description`,\n\t\toldDescription: existingOption.description,\n\t\tnewDescription: option.description\n\t});\n\n\t// Check localized descriptions\n\tconst originalLocalizedDescriptions = existingOption.description_localizations;\n\tconst expectedLocalizedDescriptions = option.description_localizations;\n\n\tyield* checkLocalizations({\n\t\tlocaleMapName: `${keyPath(currentIndex)}.descriptionLocalizations`,\n\t\tlocalePresentMessage: 'localized descriptions',\n\t\tlocaleMissingMessage: 'no localized descriptions',\n\t\toriginalLocalizedDescriptions,\n\t\texpectedLocalizedDescriptions\n\t});\n\n\t// Check required\n\tyield* checkOptionRequired({\n\t\tkey: `${keyPath(currentIndex)}.required`,\n\t\toldRequired: existingOption.required,\n\t\tnewRequired: option.required\n\t});\n\n\t// Check for subcommands\n\tif (subcommandTypes.includes(existingOption.type) && subcommandTypes.includes(option.type)) {\n\t\tconst castedExisting = existingOption as APIApplicationCommandSubcommandTypes;\n\t\tconst castedExpected = option as APIApplicationCommandSubcommandTypes;\n\n\t\tif (\n\t\t\tcastedExisting.type === ApplicationCommandOptionType.SubcommandGroup &&\n\t\t\tcastedExpected.type === ApplicationCommandOptionType.SubcommandGroup\n\t\t) {\n\t\t\t// We know we have options in this case, because they are both groups\n\t\t\tfor (const [subcommandIndex, subcommandOption] of castedExpected.options!.entries()) {\n\t\t\t\tyield* reportOptionDifferences({\n\t\t\t\t\tcurrentIndex: subcommandIndex,\n\t\t\t\t\toption: subcommandOption,\n\t\t\t\t\texistingOption: castedExisting.options?.[subcommandIndex],\n\t\t\t\t\tkeyPath: (index) => `${keyPath(currentIndex)}.options[${index}]`\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (\n\t\t\tcastedExisting.type === ApplicationCommandOptionType.Subcommand &&\n\t\t\tcastedExpected.type === ApplicationCommandOptionType.Subcommand\n\t\t) {\n\t\t\tyield* handleSubcommandOptions({\n\t\t\t\texpectedOptions: castedExpected.options,\n\t\t\t\texistingOptions: castedExisting.options,\n\t\t\t\tcurrentIndex,\n\t\t\t\tkeyPath\n\t\t\t});\n\t\t}\n\t}\n\n\tif (hasMinMaxValueSupport(option)) {\n\t\t// Check min and max_value\n\t\tconst existingCasted = existingOption as APIApplicationCommandMinAndMaxValueTypes;\n\n\t\tyield* handleMinMaxValueOptions({\n\t\t\tcurrentIndex,\n\t\t\texistingOption: existingCasted,\n\t\t\texpectedOption: option,\n\t\t\tkeyPath\n\t\t});\n\t}\n\n\tif (hasChoicesAndAutocompleteSupport(option)) {\n\t\tconst existingCasted = existingOption as APIApplicationCommandChoosableAndAutocompletableTypes;\n\n\t\tyield* handleAutocomplete({\n\t\t\texpectedOption: option,\n\t\t\texistingOption: existingCasted,\n\t\t\tcurrentIndex,\n\t\t\tkeyPath\n\t\t});\n\t}\n\n\tif (hasMinMaxLengthSupport(option)) {\n\t\t// Check min and max_value\n\t\tconst existingCasted = existingOption as APIApplicationCommandMinMaxLengthTypes;\n\n\t\tyield* handleMinMaxLengthOptions({\n\t\t\tcurrentIndex,\n\t\t\texistingOption: existingCasted,\n\t\t\texpectedOption: option,\n\t\t\tkeyPath\n\t\t});\n\t}\n\n\tif (hasChannelTypesSupport(option)) {\n\t\t// Check channel_types\n\t\tconst existingCasted = existingOption as APIApplicationCommandChannelOption;\n\n\t\tyield* checkChannelTypes({\n\t\t\tcurrentIndex,\n\t\t\texistingChannelTypes: existingCasted.channel_types,\n\t\t\tkeyPath,\n\t\t\tnewChannelTypes: option.channel_types\n\t\t});\n\t}\n}\n\nfunction* handleSubcommandOptions({\n\texpectedOptions,\n\texistingOptions,\n\tcurrentIndex,\n\tkeyPath\n}: {\n\texpectedOptions?: APIApplicationCommandBasicOption[];\n\texistingOptions?: APIApplicationCommandBasicOption[];\n\tcurrentIndex: number;\n\tkeyPath: (index: number) => string;\n}): Generator<CommandDifference> {\n\t// 0. No existing options and now we have options\n\tif (!existingOptions?.length && expectedOptions?.length) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.options`,\n\t\t\texpected: 'options present',\n\t\t\toriginal: 'no options present'\n\t\t};\n\t}\n\n\t// 1. Existing options and now we have no options\n\telse if (existingOptions?.length && !expectedOptions?.length) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.options`,\n\t\t\texpected: 'no options present',\n\t\t\toriginal: 'options present'\n\t\t};\n\t}\n\n\t// 2. Iterate over each option if we have any and see what's different\n\telse if (expectedOptions?.length) {\n\t\tlet processedIndex = 0;\n\t\tfor (const subcommandOption of expectedOptions) {\n\t\t\tconst currentSubCommandOptionIndex = processedIndex++;\n\t\t\tconst existingSubcommandOption = existingOptions![currentSubCommandOptionIndex];\n\n\t\t\tyield* reportOptionDifferences({\n\t\t\t\tcurrentIndex: currentSubCommandOptionIndex,\n\t\t\t\toption: subcommandOption,\n\t\t\t\texistingOption: existingSubcommandOption,\n\t\t\t\tkeyPath: (index) => `${keyPath(currentIndex)}.options[${index}]`\n\t\t\t});\n\t\t}\n\n\t\t// If we went through less options than we previously had, report that\n\t\tif (processedIndex < existingOptions!.length) {\n\t\t\tlet option: APIApplicationCommandOption;\n\t\t\twhile ((option = existingOptions![processedIndex]) !== undefined) {\n\t\t\t\tconst expectedType =\n\t\t\t\t\toptionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;\n\n\t\t\t\tyield {\n\t\t\t\t\tkey: `existing command option at path ${keyPath(currentIndex)}.options[${processedIndex}]`,\n\t\t\t\t\texpected: 'no option present',\n\t\t\t\t\toriginal: `${expectedType} with name ${option.name}`\n\t\t\t\t};\n\n\t\t\t\tprocessedIndex++;\n\t\t\t}\n\t\t}\n\t}\n}\n"]}