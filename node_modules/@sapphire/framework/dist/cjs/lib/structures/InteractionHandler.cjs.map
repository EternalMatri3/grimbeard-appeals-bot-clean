{"version":3,"sources":["../../../../src/lib/structures/InteractionHandler.ts"],"names":["Piece","Option","InteractionHandlerTypes"],"mappings":";;;;;;;AAKO,IAAe,mBAAA,GAAf,MAAe,mBAAA,SAAoGA,YAAA,CAGxH;AAAA,EAOM,WAAA,CAAY,SAA2C,OAAA,EAAkB;AAC/E,IAAA,KAAA,CAAM,SAAS,OAAO,CAAA;AAEtB,IAAA,IAAA,CAAK,yBAAyB,OAAA,CAAQ,sBAAA;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA+CO,MAAM,YAAA,EAAuD;AACnE,IAAA,OAAO,KAAK,IAAA,EAAK;AAAA,EAClB;AAAA,EAIO,KAAQ,IAAA,EAAsC;AACpD,IAAA,OAAOC,aAAA,CAAO,KAAK,IAAI,CAAA;AAAA,EACxB;AAAA,EAEO,IAAA,GAAoB;AAC1B,IAAA,OAAOA,aAAA,CAAO,IAAA;AAAA,EACf;AAAA,EAEgB,MAAA,GAAiC;AAChD,IAAA,OAAO;AAAA,MACN,GAAG,MAAM,MAAA,EAAO;AAAA,MAChB,wBAAwB,IAAA,CAAK;AAAA,KAC9B;AAAA,EACD;AACD,CAAA;AA9EE,MAAA,CAAA,mBAAA,EAAA,oBAAA,CAAA;AAHK,IAAe,kBAAA,GAAf;AAyGA,IAAK,uBAAA,qBAAAC,wBAAAA,KAAL;AAEN,EAAAA,wBAAAA,CAAAA,wBAAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,EAAAA,wBAAAA,CAAAA,wBAAAA,CAAA,YAAA,CAAA,GAAA,CAAA,CAAA,GAAA,YAAA;AACA,EAAAA,wBAAAA,CAAAA,wBAAAA,CAAA,aAAA,CAAA,GAAA,CAAA,CAAA,GAAA,aAAA;AAGA,EAAAA,wBAAAA,CAAAA,wBAAAA,CAAA,kBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,kBAAA;AAEA,EAAAA,wBAAAA,CAAAA,wBAAAA,CAAA,cAAA,CAAA,GAAA,CAAA,CAAA,GAAA,cAAA;AATW,EAAA,OAAAA,wBAAAA;AAAA,CAAA,EAAA,uBAAA,IAAA,EAAA","file":"InteractionHandler.cjs","sourcesContent":["import { Piece } from '@sapphire/pieces';\nimport { Option } from '@sapphire/result';\nimport type { Awaitable } from '@sapphire/utilities';\nimport type { Interaction } from 'discord.js';\n\nexport abstract class InteractionHandler<Options extends InteractionHandler.Options = InteractionHandler.Options> extends Piece<\n\tOptions,\n\t'interaction-handlers'\n> {\n\t/**\n\t * The type for this handler\n\t * @since 3.0.0\n\t */\n\tpublic readonly interactionHandlerType: InteractionHandlerTypes;\n\n\tpublic constructor(context: InteractionHandler.LoaderContext, options: Options) {\n\t\tsuper(context, options);\n\n\t\tthis.interactionHandlerType = options.interactionHandlerType;\n\t}\n\n\tpublic abstract run(interaction: Interaction, parsedData?: unknown): unknown;\n\n\t/**\n\t * A custom function that will be called when checking if an interaction should be passed to this handler.\n\t * You can use this method to not only filter by ids, but also pre-parse the data from the id for use in the run method.\n\t *\n\t * By default, all interactions of the type you specified will run in a handler. You should override this method\n\t * to change that behavior.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Parsing a button handler\n\t * public override parse(interaction: ButtonInteraction) {\n\t *   if (interaction.customId.startsWith('my-awesome-clicky-button')) {\n\t * \t   // Returning a `some` here means that the run method should be called next!\n\t *     return this.some({ isMyBotAwesome: true, awesomenessLevel: 9001 });\n\t *   }\n\t *\n\t *   // Returning a `none` means this interaction shouldn't run in this handler\n\t *   return this.none();\n\t * }\n\t * ```\n\t *\n\t * @example\n\t * ```typescript\n\t * // Getting data from a database based on the custom id\n\t * public override async parse(interaction: ButtonInteraction) {\n\t *   // This code is purely for demonstration purposes only!\n\t *   if (interaction.customId.startsWith('example-data')) {\n\t *     const [, userId, channelId] = interaction.customId.split('.');\n\t *\n\t * \t   const dataFromDatabase = await container.prisma.exampleData.findFirst({ where: { userId, channelId } });\n\t *\n\t *     // Returning a `some` here means that the run method should be called next!\n\t *     return this.some(dataFromDatabase);\n\t *   }\n\t *\n\t *   // Returning a `none` means this interaction shouldn't run in this handler\n\t *   return this.none();\n\t * }\n\t * ```\n\t *\n\t * @returns An {@link Option} (or a {@link Promise Promised} {@link Option}) that indicates if this interaction should be\n\t * handled by this handler, and any extra data that should be passed to the {@link InteractionHandler.run run method}\n\t */\n\tpublic parse(_interaction: Interaction): Awaitable<Option<unknown>> {\n\t\treturn this.some();\n\t}\n\n\tpublic some(): Option.Some<never>;\n\tpublic some<T>(data: T): Option.Some<T>;\n\tpublic some<T>(data?: T): Option.Some<T | undefined> {\n\t\treturn Option.some(data);\n\t}\n\n\tpublic none(): Option.None {\n\t\treturn Option.none;\n\t}\n\n\tpublic override toJSON(): InteractionHandlerJSON {\n\t\treturn {\n\t\t\t...super.toJSON(),\n\t\t\tinteractionHandlerType: this.interactionHandlerType\n\t\t};\n\t}\n}\n\nexport interface InteractionHandlerOptions extends Piece.Options {\n\t/**\n\t * The type of interaction this handler is for. Must be one of {@link InteractionHandlerTypes}.\n\t */\n\treadonly interactionHandlerType: InteractionHandlerTypes;\n}\n\nexport interface InteractionHandlerJSON extends Piece.JSON {\n\tinteractionHandlerType: InteractionHandlerTypes;\n}\n\nexport type InteractionHandlerParseResult<Instance extends InteractionHandler> = Option.UnwrapSome<Awaited<ReturnType<Instance['parse']>>>;\n\nexport namespace InteractionHandler {\n\t/** @deprecated Use {@linkcode LoaderContext} instead. */\n\texport type Context = LoaderContext;\n\texport type LoaderContext = Piece.LoaderContext<'interaction-handlers'>;\n\texport type Options = InteractionHandlerOptions;\n\texport type JSON = InteractionHandlerJSON;\n\texport type ParseResult<Instance extends InteractionHandler> = InteractionHandlerParseResult<Instance>;\n}\n\nexport enum InteractionHandlerTypes {\n\t// Specifically focused types\n\tButton,\n\tSelectMenu,\n\tModalSubmit,\n\n\t// More free-falling handlers, for 1 shared handler between buttons and select menus (someone will have a use for this >,>)\n\tMessageComponent,\n\t// Optional autocompletes, you can use this or in-command\n\tAutocomplete\n}\n"]}