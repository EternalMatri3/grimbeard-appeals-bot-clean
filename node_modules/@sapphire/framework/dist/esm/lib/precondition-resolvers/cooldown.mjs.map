{"version":3,"sources":["../../../../src/lib/precondition-resolvers/cooldown.ts"],"names":[],"mappings":";;;;;AAgBO,SAAS,sCACf,OAAA,EACA,aAAA,EACA,aAAA,EACA,aAAA,EACA,uBACA,0BAAA,EACC;AACD,EAAA,MAAM,EAAE,eAAA,EAAgB,GAAI,SAAA,CAAU,MAAA,CAAO,OAAA;AAK7C,EAAA,MAAM,WAAW,eAAA,EAAiB,gBAAA,EAAkB,QAAA,CAAS,OAAA,CAAQ,IAAI,CAAA,IAAK,KAAA;AAC9E,EAAA,MAAM,KAAA,GAAQ,aAAA,KAAkB,QAAA,GAAW,CAAA,GAAK,iBAAiB,KAAA,IAAS,CAAA,CAAA;AAC1E,EAAA,MAAM,KAAA,GAAQ,aAAA,KAAkB,QAAA,GAAW,CAAA,GAAK,iBAAiB,KAAA,IAAS,CAAA,CAAA;AAE1E,EAAA,IAAI,SAAS,KAAA,EAAO;AACnB,IAAA,MAAM,KAAA,GAAQ,aAAA,IAAiB,eAAA,EAAiB,KAAA,IAAS,WAAA,CAAY,IAAA;AACrE,IAAA,MAAM,aAAA,GAAgB,yBAAyB,eAAA,EAAiB,aAAA;AAChE,IAAA,0BAAA,CAA2B,MAAA,CAAO;AAAA,MACjC,MAAM,oBAAA,CAAqB,QAAA;AAAA,MAC3B,OAAA,EAAS,EAAE,KAAA,EAAO,KAAA,EAAO,OAAO,aAAA;AAAc,KAC9C,CAAA;AAAA,EACF;AACD;AAzBgB,MAAA,CAAA,qCAAA,EAAA,uCAAA,CAAA","file":"cooldown.mjs","sourcesContent":["import { container } from '@sapphire/pieces';\nimport type { Command } from '../structures/Command';\nimport { BucketScope, CommandPreConditions } from '../types/Enums';\nimport { type PreconditionContainerArray } from '../utils/preconditions/PreconditionContainerArray';\n\n/**\n * Appends the `Cooldown` precondition when {@link Command.Options.cooldownLimit} and\n * {@link Command.Options.cooldownDelay} are both non-zero.\n *\n * @param command The command to parse cooldowns for.\n * @param cooldownLimit The cooldown limit to use.\n * @param cooldownDelay The cooldown delay to use.\n * @param cooldownScope The cooldown scope to use.\n * @param cooldownFilteredUsers The cooldown filtered users to use.\n * @param preconditionContainerArray The precondition container array to append the precondition to.\n */\nexport function parseConstructorPreConditionsCooldown<P, O extends Command.Options>(\n\tcommand: Command<P, O>,\n\tcooldownLimit: number | undefined,\n\tcooldownDelay: number | undefined,\n\tcooldownScope: BucketScope | undefined,\n\tcooldownFilteredUsers: string[] | undefined,\n\tpreconditionContainerArray: PreconditionContainerArray\n) {\n\tconst { defaultCooldown } = container.client.options;\n\n\t// We will check for whether the command is filtered from the defaults, but we will allow overridden values to\n\t// be set. If an overridden value is passed, it will have priority. Otherwise, it will default to 0 if filtered\n\t// (causing the precondition to not be registered) or the default value with a fallback to a single-use cooldown.\n\tconst filtered = defaultCooldown?.filteredCommands?.includes(command.name) ?? false;\n\tconst limit = cooldownLimit ?? (filtered ? 0 : (defaultCooldown?.limit ?? 1));\n\tconst delay = cooldownDelay ?? (filtered ? 0 : (defaultCooldown?.delay ?? 0));\n\n\tif (limit && delay) {\n\t\tconst scope = cooldownScope ?? defaultCooldown?.scope ?? BucketScope.User;\n\t\tconst filteredUsers = cooldownFilteredUsers ?? defaultCooldown?.filteredUsers;\n\t\tpreconditionContainerArray.append({\n\t\t\tname: CommandPreConditions.Cooldown,\n\t\t\tcontext: { scope, limit, delay, filteredUsers }\n\t\t});\n\t}\n}\n"]}