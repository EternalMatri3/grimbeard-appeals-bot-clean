{"version":3,"sources":["../../../../src/lib/resolvers/message.ts"],"names":[],"mappings":"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","file":"message.mjs","sourcesContent":["import { ChannelMessageRegex, MessageLinkRegex, SnowflakeRegex } from '@sapphire/discord-utilities';\nimport {\n\tisAnyInteraction,\n\tisGuildBasedChannel,\n\tisNewsChannel,\n\tisStageChannel,\n\tisTextBasedChannel,\n\tisTextChannel,\n\ttype AnyInteraction,\n\ttype GuildBasedChannelTypes,\n\ttype TextBasedChannelTypes\n} from '@sapphire/discord.js-utilities';\nimport { container } from '@sapphire/pieces';\nimport { Result } from '@sapphire/result';\nimport type { Awaitable } from '@sapphire/utilities';\nimport { PermissionFlagsBits, type Message, type Snowflake, type User } from 'discord.js';\nimport { Identifiers } from '../errors/Identifiers';\n\n/**\n * Options to resolve a message from a string, given a certain context.\n */\nexport interface MessageResolverOptions {\n\t/**\n\t * Channel to resolve the message in.\n\t * @default message.channel\n\t */\n\tchannel?: TextBasedChannelTypes;\n\t/**\n\t * Base {@link Message} or {@link AnyInteraction} to resolve the message from (e.g. pick the channel if not given).\n\t */\n\tmessageOrInteraction: Message | AnyInteraction;\n\t/**\n\t * Whether to scan the entire guild cache for the message.\n\t * If channel is given with this option, this option is ignored.\n\t * @default false\n\t */\n\tscan?: boolean;\n}\n\nexport async function resolveMessage(parameter: string, options: MessageResolverOptions): Promise<Result<Message, Identifiers.ArgumentMessageError>> {\n\tconst message =\n\t\t(await resolveById(parameter, options)) ??\n\t\t(await resolveByLink(parameter, options)) ??\n\t\t(await resolveByChannelAndMessage(parameter, options));\n\n\tif (message) {\n\t\treturn Result.ok(message);\n\t}\n\n\treturn Result.err(Identifiers.ArgumentMessageError);\n}\n\nfunction resolveById(parameter: string, options: MessageResolverOptions): Awaitable<Message | null> {\n\tif (!SnowflakeRegex.test(parameter) || isStageChannel(options.messageOrInteraction.channel)) {\n\t\treturn null;\n\t}\n\n\tif (options.channel && !isStageChannel(options.channel)) {\n\t\treturn options.channel.messages.fetch(parameter as Snowflake);\n\t}\n\n\tif (options.scan && isGuildBasedChannel(options.messageOrInteraction.channel)) {\n\t\tfor (const channel of options.messageOrInteraction.channel.guild.channels.cache.values()) {\n\t\t\tif (!isTextBasedChannel(channel) || isStageChannel(channel)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst message = channel.messages.cache.get(parameter);\n\t\t\tif (message) {\n\t\t\t\treturn message;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn options.messageOrInteraction.channel?.messages.fetch(parameter as Snowflake) ?? null;\n}\n\nasync function resolveByLink(parameter: string, options: MessageResolverOptions): Promise<Message | null> {\n\tif (!options.messageOrInteraction.guild) {\n\t\treturn null;\n\t}\n\n\tconst matches = MessageLinkRegex.exec(parameter);\n\tif (!matches) {\n\t\treturn null;\n\t}\n\n\tconst [, guildId, channelId, messageId] = matches;\n\n\tconst guild = container.client.guilds.cache.get(guildId as Snowflake);\n\tif (guild !== options.messageOrInteraction.guild) {\n\t\treturn null;\n\t}\n\n\treturn getMessageFromChannel(\n\t\tchannelId,\n\t\tmessageId,\n\t\tisAnyInteraction(options.messageOrInteraction) ? options.messageOrInteraction.user : options.messageOrInteraction.author\n\t);\n}\n\nasync function resolveByChannelAndMessage(parameter: string, options: MessageResolverOptions): Promise<Message | null> {\n\tconst result = ChannelMessageRegex.exec(parameter)?.groups;\n\n\tif (!result) {\n\t\treturn null;\n\t}\n\n\treturn getMessageFromChannel(\n\t\tresult.channelId,\n\t\tresult.messageId,\n\t\tisAnyInteraction(options.messageOrInteraction) ? options.messageOrInteraction.user : options.messageOrInteraction.author\n\t);\n}\n\nasync function getMessageFromChannel(channelId: Snowflake, messageId: Snowflake, originalAuthor: User): Promise<Message | null> {\n\tconst channel = container.client.channels.cache.get(channelId) as GuildBasedChannelTypes;\n\tif (!channel) {\n\t\treturn null;\n\t}\n\n\tif (!(isNewsChannel(channel) || isTextChannel(channel))) {\n\t\treturn null;\n\t}\n\n\tif (!channel.viewable) {\n\t\treturn null;\n\t}\n\n\tif (!channel.permissionsFor(originalAuthor)?.has(PermissionFlagsBits.ViewChannel)) {\n\t\treturn null;\n\t}\n\n\treturn channel.messages.fetch(messageId);\n}\n"]}