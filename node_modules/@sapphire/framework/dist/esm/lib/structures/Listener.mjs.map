{"version":3,"sources":["../../../../src/lib/structures/Listener.ts"],"names":[],"mappings":";;;;;AA6CO,IAAe,SAAA,GAAf,MAAe,SAAA,SAAkH,KAAA,CAGtI;AAAA,EAqBM,WAAA,CAAY,OAAA,EAAiC,OAAA,GAAmB,EAAC,EAAc;AACrF,IAAA,KAAA,CAAM,SAAS,OAAO,CAAA;AAEtB,IAAA,IAAA,CAAK,OAAA,GACJ,OAAO,OAAA,CAAQ,OAAA,KAAY,cACxB,IAAA,CAAK,SAAA,CAAU,UACb,OAAO,OAAA,CAAQ,YAAY,QAAA,GAC1B,OAAA,CAAQ,IAAI,IAAA,CAAK,SAAA,CAAU,QAAQ,OAAA,CAAQ,OAAO,CAAA,GAClD,OAAA,CAAQ,OAAA,KAA6B,IAAA;AAC5C,IAAA,IAAA,CAAK,KAAA,GAAQ,OAAA,CAAQ,KAAA,IAAS,IAAA,CAAK,IAAA;AACnC,IAAA,IAAA,CAAK,IAAA,GAAO,QAAQ,IAAA,IAAQ,KAAA;AAE5B,IAAA,IAAA,CAAK,YAAY,IAAA,CAAK,OAAA,IAAW,IAAA,CAAK,KAAA,GAAS,KAAK,IAAA,GAAO,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,IAAI,CAAA,GAAI,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,IAAI,CAAA,GAAK,IAAA;AAG9G,IAAA,IAAI,KAAK,OAAA,KAAY,IAAA,IAAQ,KAAK,SAAA,KAAc,IAAA,OAAW,OAAA,GAAU,KAAA;AAAA,EACtE;AAAA,EAIgB,MAAA,GAAuB;AACtC,IAAA,OAAO;AAAA,MACN,GAAG,MAAM,MAAA,EAAO;AAAA,MAChB,MAAM,IAAA,CAAK,IAAA;AAAA,MACX,OAAO,IAAA,CAAK;AAAA,KACb;AAAA,EACD;AAAA,EAEA,MAAc,QAAQ,IAAA,EAAiB;AACtC,IAAA,MAAM,MAAA,GAAS,MAAM,MAAA,CAAO,SAAA,CAAU,MAAM,IAAA,CAAK,GAAA,CAAI,GAAI,IAAmE,CAAC,CAAA;AAC7H,IAAA,MAAA,CAAO,UAAA,CAAW,CAAC,KAAA,KAAU,IAAA,CAAK,UAAU,MAAA,CAAO,IAAA,CAAK,MAAA,CAAO,aAAA,EAAe,KAAA,EAAO,EAAE,KAAA,EAAO,IAAA,EAAM,CAAC,CAAA;AAAA,EACtG;AAAA,EAEA,MAAc,YAAY,IAAA,EAAiB;AAC1C,IAAA,MAAM,IAAA,CAAK,IAAA,CAAK,GAAG,IAAI,CAAA;AACvB,IAAA,MAAM,KAAK,MAAA,EAAO;AAAA,EACnB;AACD,CAAA;AA1DE,MAAA,CAAA,SAAA,EAAA,UAAA,CAAA;AAHK,IAAe,QAAA,GAAf","file":"Listener.mjs","sourcesContent":["import { Piece } from '@sapphire/pieces';\nimport { Result } from '@sapphire/result';\nimport type { Client, ClientEvents } from 'discord.js';\nimport type { EventEmitter } from 'node:events';\nimport { Events } from '../types/Events';\n\n/**\n * The base event class. This class is abstract and is to be extended by subclasses, which should implement the methods. In\n * Sapphire's workflow, listeners are called when the emitter they listen on emits a new message with the same event name.\n *\n * @example\n * ```typescript\n * // TypeScript:\n * import { Events, Listener } from '@sapphire/framework';\n *\n * // Define a class extending `Listener`, then export it.\n * // NOTE: You can use `export default` or `export =` too.\n * export class CoreListener extends Listener<typeof Events.ClientReady> {\n *   public constructor(context: Listener.LoaderContext) {\n *     super(context, { event: Events.ClientReady, once: true });\n *   }\n *\n *   public run() {\n *     this.container.client.id ??= this.container.client.user?.id ?? null;\n *   }\n * }\n * ```\n *\n * @example\n * ```javascript\n * // JavaScript:\n * const { Events, Listener } = require('@sapphire/framework');\n *\n * // Define a class extending `Listener`, then export it.\n * module.exports = class CoreListener extends Listener {\n *   constructor(context) {\n *     super(context, { event: Events.ClientReady, once: true });\n *   }\n *\n *   run() {\n *     this.container.client.id ??= this.container.client.user?.id ?? null;\n *   }\n * }\n * ```\n */\nexport abstract class Listener<E extends keyof ClientEvents | symbol = '', Options extends Listener.Options = Listener.Options> extends Piece<\n\tOptions,\n\t'listeners'\n> {\n\t/**\n\t * The emitter, if any.\n\t * @since 2.0.0\n\t */\n\tpublic readonly emitter: EventEmitter | null;\n\n\t/**\n\t * The name of the event the listener listens to.\n\t * @since 2.0.0\n\t */\n\tpublic readonly event: string | symbol;\n\n\t/**\n\t * Whether the listener will be unloaded after the first run.\n\t * @since 2.0.0\n\t */\n\tpublic readonly once: boolean;\n\n\tprivate _listener: ((...args: any[]) => void) | null;\n\n\tpublic constructor(context: Listener.LoaderContext, options: Options = {} as Options) {\n\t\tsuper(context, options);\n\n\t\tthis.emitter =\n\t\t\ttypeof options.emitter === 'undefined'\n\t\t\t\t? this.container.client\n\t\t\t\t: ((typeof options.emitter === 'string'\n\t\t\t\t\t\t? (Reflect.get(this.container.client, options.emitter) as EventEmitter)\n\t\t\t\t\t\t: (options.emitter as EventEmitter)) ?? null);\n\t\tthis.event = options.event ?? this.name;\n\t\tthis.once = options.once ?? false;\n\n\t\tthis._listener = this.emitter && this.event ? (this.once ? this._runOnce.bind(this) : this._run.bind(this)) : null;\n\n\t\t// If there's no emitter or no listener, disable:\n\t\tif (this.emitter === null || this._listener === null) this.enabled = false;\n\t}\n\n\tpublic abstract run(...args: E extends keyof ClientEvents ? ClientEvents[E] : unknown[]): unknown;\n\n\tpublic override toJSON(): ListenerJSON {\n\t\treturn {\n\t\t\t...super.toJSON(),\n\t\t\tonce: this.once,\n\t\t\tevent: this.event\n\t\t};\n\t}\n\n\tprivate async _run(...args: unknown[]) {\n\t\tconst result = await Result.fromAsync(() => this.run(...(args as E extends keyof ClientEvents ? ClientEvents[E] : unknown[])));\n\t\tresult.inspectErr((error) => this.container.client.emit(Events.ListenerError, error, { piece: this }));\n\t}\n\n\tprivate async _runOnce(...args: unknown[]) {\n\t\tawait this._run(...args);\n\t\tawait this.unload();\n\t}\n}\n\nexport interface ListenerOptions extends Piece.Options {\n\treadonly emitter?: keyof Client | EventEmitter;\n\treadonly event?: string | symbol;\n\treadonly once?: boolean;\n}\n\nexport interface ListenerJSON extends Piece.JSON {\n\tevent: string | symbol;\n\tonce: boolean;\n}\n\nexport namespace Listener {\n\texport type Options = ListenerOptions;\n\texport type JSON = ListenerJSON;\n\t/** @deprecated Use {@linkcode LoaderContext} instead. */\n\texport type Context = LoaderContext;\n\texport type LoaderContext = Piece.LoaderContext<'listeners'>;\n}\n"]}