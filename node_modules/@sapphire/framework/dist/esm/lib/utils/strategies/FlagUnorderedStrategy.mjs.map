{"version":3,"sources":["../../../../../src/lib/utils/strategies/FlagUnorderedStrategy.ts"],"names":[],"mappings":";;;;AAoCA,IAAM,KAAA,mBAAQ,MAAA,CAAA,MAAM,MAAA,CAAO,IAAA,EAAb,OAAA,CAAA;AACd,IAAM,MAAA,gCAAe,IAAA,EAAN,QAAA,CAAA;AAER,IAAM,sBAAA,GAAN,MAAM,sBAAA,SAA8B,gBAAA,CAAiB;AAAA,EAIpD,YAAY,EAAE,KAAA,EAAO,OAAA,EAAS,QAAA,GAAW,CAAC,IAAA,EAAM,GAAA,EAAK,QAAG,CAAA,EAAG,aAAa,CAAC,GAAA,EAAK,GAAG,CAAA,EAAE,GAAyB,EAAC,EAAG;AACtH,IAAA,KAAA,CAAM,UAAU,UAAU,CAAA;AAC1B,IAAA,IAAA,CAAK,KAAA,GAAQ,SAAS,EAAC;AACvB,IAAA,IAAA,CAAK,OAAA,GAAU,WAAW,EAAC;AAE3B,IAAA,IAAI,IAAA,CAAK,KAAA,KAAU,IAAA,EAAM,IAAA,CAAK,WAAA,GAAc,MAAA;AAAA,SAAA,IACnC,IAAA,CAAK,KAAA,CAAM,MAAA,KAAW,CAAA,OAAQ,SAAA,GAAY,KAAA;AAEnD,IAAA,IAAI,IAAA,CAAK,YAAY,IAAA,EAAM;AAC1B,MAAA,IAAA,CAAK,aAAA,GAAgB,MAAA;AAAA,IACtB,CAAA,MAAA,IAAW,IAAA,CAAK,OAAA,CAAQ,MAAA,KAAW,CAAA,EAAG;AACrC,MAAA,IAAA,CAAK,WAAA,GAAc,KAAA;AAAA,IACpB;AAAA,EACD;AAAA,EAEgB,UAAU,CAAA,EAA2B;AACpD,IAAA,MAAM,MAAA,GAAS,KAAA,CAAM,SAAA,CAAU,CAAC,CAAA;AAGhC,IAAA,IAAI,MAAA,CAAO,UAAU,CAAC,KAAA,KAAU,KAAK,WAAA,CAAY,KAAK,CAAC,CAAA,EAAG,OAAO,MAAA;AAGjE,IAAA,OAAO,MAAA,CAAO,IAAA;AAAA,EACf;AAAA,EAEgB,YAAY,CAAA,EAA0D;AACrF,IAAA,MAAM,MAAA,GAAS,KAAA,CAAM,WAAA,CAAY,CAAC,CAAA;AAElC,IAAA,IAAI,MAAA,CAAO,SAAA,CAAU,CAAC,MAAA,KAAW,IAAA,CAAK,aAAA,CAAc,MAAA,CAAO,CAAC,CAAC,CAAC,CAAA,EAAG,OAAO,MAAA;AAExE,IAAA,OAAO,MAAA,CAAO,IAAA;AAAA,EACf;AAAA,EAEQ,YAAY,CAAA,EAAW;AAC9B,IAAA,OAAQ,IAAA,CAAK,KAAA,CAA4B,QAAA,CAAS,CAAC,CAAA;AAAA,EACpD;AAAA,EAEQ,cAAc,CAAA,EAAW;AAChC,IAAA,OAAQ,IAAA,CAAK,OAAA,CAA8B,QAAA,CAAS,CAAC,CAAA;AAAA,EACtD;AACD,CAAA;AA5C4D,MAAA,CAAA,sBAAA,EAAA,uBAAA,CAAA;AAArD,IAAM,qBAAA,GAAN","file":"FlagUnorderedStrategy.mjs","sourcesContent":["import { PrefixedStrategy } from '@sapphire/lexure';\nimport { Option } from '@sapphire/result';\n\n/**\n * The strategy options used in Sapphire.\n */\nexport interface FlagStrategyOptions {\n\t/**\n\t * The accepted flags. Flags are key-only identifiers that can be placed anywhere in the command. Two different types are accepted:\n\t * * An array of strings, e.g. [`silent`].\n\t * * A boolean defining whether the strategy should accept all keys (`true`) or none at all (`false`).\n\t * @default []\n\t */\n\tflags?: readonly string[] | boolean;\n\n\t/**\n\t * The accepted options. Options are key-value identifiers that can be placed anywhere in the command. Two different types are accepted:\n\t * * An array of strings, e.g. [`silent`].\n\t * * A boolean defining whether the strategy should accept all keys (`true`) or none at all (`false`).\n\t * @default []\n\t */\n\toptions?: readonly string[] | boolean;\n\n\t/**\n\t * The prefixes for both flags and options.\n\t * @default ['--', '-', '—']\n\t */\n\tprefixes?: string[];\n\n\t/**\n\t * The flag separators.\n\t * @default ['=', ':']\n\t */\n\tseparators?: string[];\n}\n\nconst never = () => Option.none;\nconst always = () => true;\n\nexport class FlagUnorderedStrategy extends PrefixedStrategy {\n\tpublic readonly flags: readonly string[] | true;\n\tpublic readonly options: readonly string[] | true;\n\n\tpublic constructor({ flags, options, prefixes = ['--', '-', '—'], separators = ['=', ':'] }: FlagStrategyOptions = {}) {\n\t\tsuper(prefixes, separators);\n\t\tthis.flags = flags || [];\n\t\tthis.options = options || [];\n\n\t\tif (this.flags === true) this.allowedFlag = always;\n\t\telse if (this.flags.length === 0) this.matchFlag = never;\n\n\t\tif (this.options === true) {\n\t\t\tthis.allowedOption = always;\n\t\t} else if (this.options.length === 0) {\n\t\t\tthis.matchOption = never;\n\t\t}\n\t}\n\n\tpublic override matchFlag(s: string): Option<string> {\n\t\tconst result = super.matchFlag(s);\n\n\t\t// The flag must be an allowed one.\n\t\tif (result.isSomeAnd((value) => this.allowedFlag(value))) return result;\n\n\t\t// If it did not match a flag, return null.\n\t\treturn Option.none;\n\t}\n\n\tpublic override matchOption(s: string): Option<readonly [key: string, value: string]> {\n\t\tconst result = super.matchOption(s);\n\n\t\tif (result.isSomeAnd((option) => this.allowedOption(option[0]))) return result;\n\n\t\treturn Option.none;\n\t}\n\n\tprivate allowedFlag(s: string) {\n\t\treturn (this.flags as readonly string[]).includes(s);\n\t}\n\n\tprivate allowedOption(s: string) {\n\t\treturn (this.options as readonly string[]).includes(s);\n\t}\n}\n"]}