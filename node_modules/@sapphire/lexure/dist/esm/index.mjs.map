{"version":3,"sources":["../../src/lib/ArgumentStream.ts","../../src/lib/lexer/streams/parameters/BaseParameter.ts","../../src/lib/lexer/streams/parameters/QuotedParameter.ts","../../src/lib/lexer/streams/parameters/WordParameter.ts","../../src/lib/lexer/streams/raw/TokenStream.ts","../../src/lib/lexer/streams/ParameterStream.ts","../../src/lib/lexer/Lexer.ts","../../src/lib/parser/ParserResult.ts","../../src/lib/parser/strategies/EmptyStrategy.ts","../../src/lib/parser/Parser.ts","../../src/lib/parser/strategies/PrefixedStrategy.ts","../../src/lib/util/util.ts"],"names":["TokenType","Option"],"mappings":"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","file":"index.mjs","sourcesContent":["import { Option, Result } from '@sapphire/result';\nimport type { Parameter } from './lexer/streams/ParameterStream';\nimport type { ParserResult } from './parser/ParserResult';\n\nexport class ArgumentStream {\n\tpublic readonly results: ParserResult;\n\tpublic state: ArgumentStream.State;\n\n\tpublic constructor(results: ParserResult) {\n\t\tthis.results = results;\n\t\tthis.state = { used: new Set(), position: 0 };\n\t}\n\n\t/**\n\t * Whether or not all ordered parameters were used.\n\t */\n\tpublic get finished() {\n\t\treturn this.used === this.length;\n\t}\n\n\t/**\n\t * The amount of ordered parameters.\n\t */\n\tpublic get length() {\n\t\treturn this.results.ordered.length;\n\t}\n\n\t/**\n\t * The remaining amount of ordered parameters.\n\t */\n\tpublic get remaining() {\n\t\treturn this.length - this.used;\n\t}\n\n\t/**\n\t * The amount of ordered parameters that have been used.\n\t */\n\tpublic get used() {\n\t\treturn this.state.used.size;\n\t}\n\n\t/**\n\t * Retrieves the value of the next unused ordered token.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(args.single());\n\t * // Ok { value: '1' }\n\t *\n\t * console.log(args.single());\n\t * // Ok { value: '2' }\n\t *\n\t * console.log(args.single());\n\t * // Ok { value: '3' }\n\t *\n\t * console.log(args.single());\n\t * // None\n\t * ```\n\t *\n\t * @returns The value, if any.\n\t */\n\tpublic single(): Option<string> {\n\t\tif (this.finished) return Option.none;\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tthis.state.used.add(this.state.position);\n\t\treturn Option.some(this.results.ordered[this.state.position++].value);\n\t}\n\n\t/**\n\t * Retrieves the value of the next unused ordered token, but only if it could be transformed.\n\t *\n\t * @note This does not support asynchronous results, refer to {@link singleMapAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * const parse = (value) => {\n\t *   const number = Number(value);\n\t *   return Number.isNaN(number) ? Option.none : Option.some(number);\n\t * };\n\t *\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(args.singleMap(parse));\n\t * // Some { value: 1 }\n\t *\n\t * console.log(args.singleMap(parse));\n\t * // Some { value: 2 }\n\t *\n\t * console.log(args.singleMap(parse));\n\t * // Some { value: 3 }\n\t *\n\t * console.log(args.singleMap(parse));\n\t * // None\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.\n\t * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.\n\t * @returns The mapped value, if any.\n\t */\n\tpublic singleMap<T>(predicate: (value: string) => Option<T>, useAnyways = false): Option<T> {\n\t\tif (this.finished) return Option.none;\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tconst result = predicate(this.results.ordered[this.state.position].value);\n\t\tif (result.isSome() || useAnyways) {\n\t\t\tthis.state.used.add(this.state.position);\n\t\t\t++this.state.position;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Retrieves the value of the next unused ordered token, but only if it could be transformed.\n\t *\n\t * @note This is an asynchronous variant of {@link singleMap}.\n\t *\n\t * @typeparam T The output type.\n\t * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.\n\t * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.\n\t * @returns The mapped value, if any.\n\t */\n\tpublic async singleMapAsync<T>(predicate: (value: string) => Promise<Option<T>>, useAnyways = false): Promise<Option<T>> {\n\t\tif (this.finished) return Option.none;\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tconst result = await predicate(this.results.ordered[this.state.position].value);\n\t\tif (result.isSome() || useAnyways) {\n\t\t\tthis.state.used.add(this.state.position);\n\t\t\t++this.state.position;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Finds and retrieves the next unused parameter and transforms it.\n\t *\n\t * @note This is a variant of {@link findMap} that returns the errors on failure.\n\t * @note This does not support asynchronous results, refer to {@link singleParseAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * const parse = (value) => {\n\t *   const number = Number(value);\n\t *   return Number.isNaN(number)\n\t *     ? Result.err(`Could not parse ${value} to a number`)\n\t *     : Result.ok(number);\n\t * };\n\t *\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(args.singleParse(parse));\n\t * // Ok { value: 1 }\n\t *\n\t * console.log(args.singleParse(parse));\n\t * // Ok { value: 2 }\n\t *\n\t * console.log(args.singleParse(parse));\n\t * // Ok { value: 3 }\n\t *\n\t * console.log(args.singleParse(parse));\n\t * // Err { error: null }\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @typeparam E The error type.\n\t * @param predicate The predicate that determines the parameter's transformed value, or nothing if failed.\n\t * @param useAnyways Whether to consider the parameter used even if the transformation failed. Defaults to `false`.\n\t * @returns The transformed value, if any.\n\t */\n\tpublic singleParse<T, E>(predicate: (value: string) => Result<T, E>, useAnyways = false): Result<T, E | null> {\n\t\tif (this.finished) return Result.err(null);\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tconst result = predicate(this.results.ordered[this.state.position].value);\n\t\tif (result.isOk() || useAnyways) {\n\t\t\tthis.state.used.add(this.state.position);\n\t\t\t++this.state.position;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Retrieves the value of the next unused ordered token, but only if it could be transformed.\n\t *\n\t * @note This is an asynchronous variant of {@link singleParse}.\n\t *\n\t * @typeparam T The output type.\n\t * @typeparam E The error type.\n\t * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.\n\t * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.\n\t * @returns The mapped value, if any.\n\t */\n\tpublic async singleParseAsync<T, E>(predicate: (value: string) => Promise<Result<T, E>>, useAnyways = false): Promise<Result<T, E | null>> {\n\t\tif (this.finished) return Result.err(null);\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tconst result = await predicate(this.results.ordered[this.state.position].value);\n\t\tif (result.isOk() || useAnyways) {\n\t\t\tthis.state.used.add(this.state.position);\n\t\t\t++this.state.position;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns the value of the first element in the array within `Option.some` where `predicate` returns `true`, and\n\t * `Option.none` otherwise.\n\t *\n\t * @note This does not support asynchronous results, refer to {@link findAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Suppose args are from 'ba aa cc'.\n\t *\n\t * console.log(args.find((value) => value.startsWith('a')));\n\t * // Some { value: 'aa' }\n\t * ```\n\t *\n\t * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it\n\t * finds one where `predicate` returns `true`. If such an element is found, find immediately returns a `Option.some`\n\t * with that element value. Otherwise, find returns `Option.none`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic find(predicate: (value: string) => boolean, from = this.state.position): Option<string> {\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tif (predicate(parameter)) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn Option.some(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn Option.none;\n\t}\n\n\t/**\n\t * Returns the value of the first element in the array within `Option.some` where `predicate` returns `true`, and\n\t * `Option.none` otherwise.\n\t *\n\t * @note This is an asynchronous variant of {@link find}.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Suppose args are from 'ba aa cc'.\n\t *\n\t * console.log(args.find((value) => value.startsWith('a')));\n\t * // Some { value: 'aa' }\n\t * ```\n\t *\n\t * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it\n\t * finds one where `predicate` returns `true`. If such an element is found, find immediately returns a `Option.some`\n\t * with that element value. Otherwise, find returns `Option.none`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic async findAsync(predicate: (value: string) => Promise<boolean>, from = this.state.position): Promise<Option<string>> {\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tif (await predicate(parameter)) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn Option.some(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn Option.none;\n\t}\n\n\t/**\n\t * Returns the value of the first element in the array within `Option.some` where `predicate` returns `Some`, and\n\t * `Option.none` otherwise.\n\t *\n\t * @note This does not support asynchronous results, refer to {@link findMapAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Suppose args are from 'ba aa cc'.\n\t *\n\t * console.log(args.find((value) => value.startsWith('a')));\n\t * // Some { value: 'aa' }\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it\n\t * finds one where `predicate` returns `Some`. If such an element is found, find immediately returns the returned\n\t * value. Otherwise, find returns `Option.none`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic findMap<T>(predicate: (value: string) => Option<T>, from = this.state.position): Option<T> {\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = predicate(parameter);\n\t\t\tif (result.isSome()) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn Option.none;\n\t}\n\n\t/**\n\t * Returns the value of the first element in the array within `Option.some` where `predicate` returns `Some`, and\n\t * `Option.none` otherwise.\n\t *\n\t * @note This is an asynchronous variant of {@link findMap}.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Suppose args are from 'ba aa cc'.\n\t *\n\t * console.log(args.find((value) => value.startsWith('a')));\n\t * // Some { value: 'aa' }\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it\n\t * finds one where `predicate` returns `Some`. If such an element is found, find immediately returns the returned\n\t * value. Otherwise, find returns `Option.none`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic async findMapAsync<T>(predicate: (value: string) => Promise<Option<T>>, from = this.state.position): Promise<Option<T>> {\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = await predicate(parameter);\n\t\t\tif (result.isSome()) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn Option.none;\n\t}\n\n\t/**\n\t * Finds and retrieves the first unused parameter that could be transformed.\n\t *\n\t * @note This is a variant of {@link findMap} that returns the errors on failure.\n\t * @note This does not support asynchronous results, refer to {@link findParseAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * const parse = (value) => {\n\t *   const number = Number(value);\n\t *   return Number.isNaN(number)\n\t *     ? Result.err(`Could not parse ${value} to a number`)\n\t *     : Result.ok(number);\n\t * };\n\t *\n\t * // Suppose args are from 'ba 1 cc'.\n\t *\n\t * console.log(args.findParse(parse));\n\t * // Ok { value: 1 }\n\t *\n\t * console.log(args.findParse(parse));\n\t * // Err {\n\t * //   error: [\n\t * //     'Could not parse ba to a number',\n\t * //     'Could not parse cc to a number'\n\t * //   ]\n\t * // }\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @typeparam E The error type.\n\t * @param predicate `findParse` calls `predicate` once for each unused ordered parameter, in ascending order, until\n\t * it finds one where `predicate` returns `Ok`. If such an element is found, `findParse` immediately returns the\n\t * returned value. Otherwise, `findParse` returns `Result.Err` with all the returned errors.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic findParse<T, E>(predicate: (value: string) => Result<T, E>, from = this.state.position): Result<T, E[]> {\n\t\tconst errors: E[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = predicate(parameter);\n\t\t\tif (result.isOk()) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn result as Result.Ok<T>;\n\t\t\t}\n\n\t\t\terrors.push(result.unwrapErr());\n\t\t}\n\n\t\treturn Result.err(errors);\n\t}\n\n\t/**\n\t * Finds and retrieves the first unused parameter that could be transformed.\n\t *\n\t * @note This is a variant of {@link findMapAsync} that returns the errors on failure.\n\t * @note This is an asynchronous variant of {@link findParse}.\n\t *\n\t * @typeparam T The output type.\n\t * @typeparam E The error type.\n\t * @param predicate `findParse` calls `predicate` once for each unused ordered parameter, in ascending order, until\n\t * it finds one where `predicate` returns `Ok`. If such an element is found, `findParse` immediately returns the\n\t * returned value. Otherwise, `findParse` returns `Result.Err` with all the returned errors.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic async findParseAsync<T, E>(predicate: (value: string) => Promise<Result<T, E>>, from = this.state.position): Promise<Result<T, E[]>> {\n\t\tconst errors: E[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = await predicate(parameter);\n\t\t\tif (result.isOk()) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn result as Result.Ok<T>;\n\t\t\t}\n\n\t\t\terrors.push(result.unwrapErr());\n\t\t}\n\n\t\treturn Result.err(errors);\n\t}\n\n\t/**\n\t * Retrieves multiple unused parameters.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(join(args.many().unwrap()));\n\t * // '1 2 3'\n\t * ```\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(join(args.many(2).unwrap()));\n\t * // '1 2'\n\t * ```\n\t *\n\t * @param limit The maximum amount of parameters to retrieve, defaults to `Infinity`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The unused parameters within the range.\n\t */\n\tpublic many(limit = Infinity, from = this.state.position): Option<Parameter[]> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: Parameter[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\t// If the current parameter was already used, skip:\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\t// Mark current parameter as used, and push it to the resulting array:\n\t\t\tthis.state.used.add(i);\n\t\t\tparameters.push(this.results.ordered[i]);\n\n\t\t\t// If the parameters reached the limit, break the loop:\n\t\t\tif (parameters.length >= limit) break;\n\t\t}\n\n\t\treturn parameters.length ? Option.some(parameters) : Option.none;\n\t}\n\n\tpublic filter(predicate: (value: string) => boolean, from = this.state.position): Option<string[]> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: string[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tif (predicate(parameter)) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\tparameters.push(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn Option.some(parameters);\n\t}\n\n\tpublic async filterAsync(predicate: (value: string) => Promise<boolean>, from = this.state.position): Promise<Option<string[]>> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: string[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tif (await predicate(parameter)) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\tparameters.push(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn Option.some(parameters);\n\t}\n\n\tpublic filterMap<T>(predicate: (value: string) => Option<T>, from = this.state.position): Option<T[]> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: T[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = predicate(parameter);\n\t\t\tresult.inspect((value) => {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\tparameters.push(value);\n\t\t\t});\n\t\t}\n\n\t\treturn Option.some(parameters);\n\t}\n\n\tpublic async filterMapAsync<T>(predicate: (value: string) => Promise<Option<T>>, from = this.state.position): Promise<Option<T[]>> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: T[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = await predicate(parameter);\n\t\t\tresult.inspect((value) => {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\tparameters.push(value);\n\t\t\t});\n\t\t}\n\n\t\treturn Option.some(parameters);\n\t}\n\n\t/**\n\t * Checks whether any of the flags were given.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '--f --g':\n\t *\n\t * console.log(args.flag('f'));\n\t * // true\n\t *\n\t * console.log(args.flag('g', 'h'));\n\t * // true\n\t *\n\t * console.log(args.flag('h'));\n\t * // false\n\t * ```\n\t *\n\t * @param keys The names of the flags to check.\n\t * @returns Whether or not any of the flags were given.\n\t */\n\tpublic flag(...keys: readonly string[]): boolean {\n\t\treturn keys.some((key) => this.results.flags.has(key));\n\t}\n\n\t/**\n\t * Gets the last value of any option. When there are multiple names, the last value of the last found name is given.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '--a=1 --b=2 --c=3'.\n\t * console.log(args.option('a'));\n\t * // Some { value: '1' }\n\t *\n\t * console.log(args.option('b', 'c'));\n\t * // Some { value: '3' }\n\t *\n\t * console.log(args.option('d'));\n\t * // None {}\n\t * ```\n\t *\n\t * @param keys The names of the options to check.\n\t * @returns The last value of the option, if any.\n\t */\n\tpublic option(...keys: readonly string[]): Option<string> {\n\t\treturn this.options(...keys).map((values) => values.at(-1)!);\n\t}\n\n\t/**\n\t * Gets all values from all options.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '--a=1 --a=1 --b=2 --c=3'.\n\t * console.log(args.option('a'));\n\t * // Some { value: ['1', '1'] }\n\t *\n\t * console.log(args.option('b', 'c'));\n\t * // Some { value: ['2', '3'] }\n\t *\n\t * console.log(args.option('d'));\n\t * // None {}\n\t * ```\n\t *\n\t * @param keys The names of the options to check.\n\t * @returns The values from all the options concatenated, if any.\n\t */\n\tpublic options(...keys: readonly string[]): Option<readonly string[]> {\n\t\tconst entries: string[] = [];\n\t\tfor (const key of keys) {\n\t\t\tconst values = this.results.options.get(key);\n\t\t\tif (values) entries.push(...values);\n\t\t}\n\n\t\treturn entries.length ? Option.some(entries) : Option.none;\n\t}\n\n\tpublic save(): ArgumentStream.State {\n\t\treturn {\n\t\t\tused: new Set(this.state.used),\n\t\t\tposition: this.state.position\n\t\t};\n\t}\n\n\tpublic restore(state: ArgumentStream.State) {\n\t\tthis.state = state;\n\t}\n\n\tpublic reset() {\n\t\tthis.restore({ used: new Set(), position: 0 });\n\t}\n}\n\nexport namespace ArgumentStream {\n\texport interface State {\n\t\tused: Set<number>;\n\t\tposition: number;\n\t}\n}\n","export abstract class BaseParameter {\n\tpublic readonly separators: readonly string[];\n\n\tpublic constructor(separators: readonly string[]) {\n\t\tthis.separators = separators;\n\t}\n\n\tpublic get leading(): string {\n\t\treturn this.separators.join('');\n\t}\n\n\tpublic abstract get raw(): string;\n}\n","import type { QuotedToken } from '../raw/TokenStream';\nimport { BaseParameter } from './BaseParameter';\n\nexport class QuotedParameter extends BaseParameter {\n\tpublic readonly value: string;\n\tpublic readonly open: string;\n\tpublic readonly close: string;\n\n\tpublic constructor(separators: readonly string[], part: Omit<QuotedToken, 'type'>) {\n\t\tsuper(separators);\n\t\tthis.value = part.value;\n\t\tthis.open = part.open;\n\t\tthis.close = part.close;\n\t}\n\n\tpublic get raw() {\n\t\treturn `${this.open}${this.value}${this.close}`;\n\t}\n}\n","import type { WordToken } from '../raw/TokenStream';\nimport { BaseParameter } from './BaseParameter';\n\nexport class WordParameter extends BaseParameter {\n\tpublic readonly value: string;\n\n\tpublic constructor(separators: readonly string[], part: Omit<WordToken, 'type'>) {\n\t\tsuper(separators);\n\t\tthis.value = part.value;\n\t}\n\n\tpublic get raw() {\n\t\treturn this.value;\n\t}\n}\n","import type { Lexer } from '../../Lexer';\n\nexport class TokenStream implements Iterable<Token> {\n\tprivate readonly input: string;\n\tprivate readonly quotes: readonly [string, string][];\n\tprivate readonly separator: string;\n\tprivate position = 0;\n\n\tpublic constructor(lexer: Lexer, input: string) {\n\t\tthis.quotes = lexer.quotes;\n\t\tthis.separator = lexer.separator;\n\t\tthis.input = input;\n\t}\n\n\tpublic get finished() {\n\t\treturn this.position >= this.input.length;\n\t}\n\n\tpublic *[Symbol.iterator](): Iterator<Token> {\n\t\twhile (!this.finished) {\n\t\t\tyield this.getPossibleSeparator() ?? this.getPossibleQuotedArgument() ?? this.getParameter();\n\t\t}\n\t}\n\n\tprivate getPossibleSeparator(): SeparatorToken | null {\n\t\tif (this.input.startsWith(this.separator, this.position)) {\n\t\t\tthis.position += this.separator.length;\n\t\t\treturn { type: TokenType.Separator, value: this.separator };\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate getPossibleQuotedArgument(): QuotedToken | null {\n\t\tfor (const [open, close] of this.quotes) {\n\t\t\tif (!this.input.startsWith(open, this.position)) continue;\n\n\t\t\tconst end = this.input.indexOf(close, this.position + open.length);\n\t\t\tif (end === -1) continue;\n\n\t\t\tconst value = this.input.slice(this.position + open.length, end);\n\t\t\tthis.position = end + close.length;\n\n\t\t\treturn { type: TokenType.Quoted, value, open, close };\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate getParameter(): WordToken {\n\t\tconst index = this.input.indexOf(this.separator, this.position);\n\t\tconst value = index === -1 ? this.input.slice(this.position) : this.input.slice(this.position, index);\n\t\tthis.position += value.length;\n\t\treturn { type: TokenType.Parameter, value };\n\t}\n}\n\nexport enum TokenType {\n\tParameter,\n\tQuoted,\n\tSeparator\n}\n\nexport type Token = WordToken | QuotedToken | SeparatorToken;\n\nexport interface WordToken {\n\treadonly type: TokenType.Parameter;\n\treadonly value: string;\n}\n\nexport interface QuotedToken {\n\treadonly type: TokenType.Quoted;\n\treadonly value: string;\n\treadonly open: string;\n\treadonly close: string;\n}\n\nexport interface SeparatorToken {\n\treadonly type: TokenType.Separator;\n\treadonly value: string;\n}\n","import { QuotedParameter } from './parameters/QuotedParameter';\nimport { WordParameter } from './parameters/WordParameter';\nimport { TokenType, type Token } from './raw/TokenStream';\n\nexport class ParameterStream {\n\tprivate readonly stream: Iterable<Token>;\n\tprivate separators: string[] = [];\n\n\tpublic constructor(stream: Iterable<Token>) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic *[Symbol.iterator](): Iterator<Parameter, string[]> {\n\t\tfor (const part of this.stream) {\n\t\t\tif (part.type === TokenType.Separator) {\n\t\t\t\tthis.separators.push(part.value);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tyield part.type === TokenType.Quoted ? new QuotedParameter(this.separators, part) : new WordParameter(this.separators, part);\n\t\t\tthis.separators = [];\n\t\t}\n\n\t\treturn this.separators;\n\t}\n}\n\nexport type Parameter = QuotedParameter | WordParameter;\n","import { ParameterStream } from './streams/ParameterStream';\nimport { TokenStream } from './streams/raw/TokenStream';\n\nexport class Lexer {\n\tpublic readonly quotes: readonly [open: string, close: string][];\n\tpublic readonly separator: string;\n\n\tpublic constructor(options: Lexer.Options = {}) {\n\t\tthis.quotes = options.quotes ?? [];\n\t\tthis.separator = options.separator ?? ' ';\n\t}\n\n\tpublic run(input: string) {\n\t\treturn new ParameterStream(this.raw(input));\n\t}\n\n\tpublic raw(input: string) {\n\t\treturn new TokenStream(this, input);\n\t}\n}\n\nexport namespace Lexer {\n\texport interface Options {\n\t\tseparator?: string;\n\t\tquotes?: readonly [open: string, close: string][];\n\t}\n}\n","import type { Parameter } from '../lexer/streams/ParameterStream';\nimport type { Parser } from './Parser';\nimport type { IUnorderedStrategy } from './strategies/IUnorderedStrategy';\n\nexport class ParserResult {\n\tpublic readonly ordered: Parameter[] = [];\n\tpublic readonly flags = new Set<string>();\n\tpublic readonly options = new Map<string, string[]>();\n\tprivate readonly strategy: IUnorderedStrategy;\n\n\tpublic constructor(parser: Parser) {\n\t\tthis.strategy = parser.strategy;\n\t}\n\n\tpublic parse(parameters: Iterable<Parameter>) {\n\t\tfor (const parameter of parameters) {\n\t\t\tthis.parsePossibleFlag(parameter) || this.parsePossibleOptions(parameter) || this.parseOrdered(parameter);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprivate parsePossibleFlag(parameter: Parameter): boolean {\n\t\treturn this.strategy\n\t\t\t.matchFlag(parameter.value)\n\t\t\t.inspect((value) => this.flags.add(value))\n\t\t\t.isSome();\n\t}\n\n\tprivate parsePossibleOptions(parameter: Parameter): boolean {\n\t\treturn this.strategy\n\t\t\t.matchOption(parameter.value)\n\t\t\t.inspect(([key, value]) => {\n\t\t\t\tconst existing = this.options.get(key);\n\t\t\t\tif (existing) existing.push(value);\n\t\t\t\telse this.options.set(key, [value]);\n\t\t\t})\n\t\t\t.isSome();\n\t}\n\n\tprivate parseOrdered(parameter: Parameter): boolean {\n\t\tthis.ordered.push(parameter);\n\t\treturn true;\n\t}\n}\n","import { Option } from '@sapphire/result';\nimport type { IUnorderedStrategy } from './IUnorderedStrategy';\n\nexport class EmptyStrategy implements IUnorderedStrategy {\n\tpublic matchFlag(): Option<string> {\n\t\treturn Option.none;\n\t}\n\n\tpublic matchOption(): Option<readonly [key: string, value: string]> {\n\t\treturn Option.none;\n\t}\n}\n","import type { Parameter } from '../lexer/streams/ParameterStream';\nimport type { IUnorderedStrategy } from './strategies/IUnorderedStrategy';\nimport { ParserResult } from './ParserResult';\nimport { EmptyStrategy } from './strategies/EmptyStrategy';\n\nexport class Parser {\n\tpublic strategy: IUnorderedStrategy;\n\n\tpublic constructor(strategy?: IUnorderedStrategy) {\n\t\tthis.strategy = strategy ?? new EmptyStrategy();\n\t}\n\n\tpublic setUnorderedStrategy(strategy: IUnorderedStrategy) {\n\t\tthis.strategy = strategy;\n\t\treturn this;\n\t}\n\n\tpublic run(input: Iterable<Parameter>): ParserResult {\n\t\treturn new ParserResult(this).parse(input);\n\t}\n}\n","import { Option } from '@sapphire/result';\nimport type { IUnorderedStrategy } from './IUnorderedStrategy';\n\nexport class PrefixedStrategy implements IUnorderedStrategy {\n\tpublic readonly prefixes: readonly string[];\n\tpublic readonly separators: readonly string[];\n\n\tpublic constructor(prefixes: readonly string[], separators: readonly string[]) {\n\t\tthis.prefixes = prefixes;\n\t\tthis.separators = separators;\n\t}\n\n\tpublic matchFlag(input: string): Option<string> {\n\t\tconst prefix = this.prefixes.find((x) => input.startsWith(x));\n\n\t\t// If the prefix is missing, return None:\n\t\tif (!prefix) return Option.none;\n\n\t\t// If the separator is present, return None:\n\t\tif (this.separators.some((x) => input.includes(x, prefix.length))) return Option.none;\n\n\t\treturn Option.some(input.slice(prefix.length));\n\t}\n\n\tpublic matchOption(input: string): Option<readonly [key: string, value: string]> {\n\t\tconst prefix = this.prefixes.find((x) => input.startsWith(x));\n\n\t\t// If the prefix is missing, return None:\n\t\tif (!prefix) return Option.none;\n\n\t\tfor (const separator of this.separators) {\n\t\t\tconst index = input.indexOf(separator, prefix.length + 1);\n\n\t\t\t// If the separator is missing, skip:\n\t\t\tif (index === -1) continue;\n\n\t\t\t// If the separator is present, but has no value, return None:\n\t\t\tif (index + separator.length === input.length) return Option.none;\n\n\t\t\tconst key = input.slice(prefix.length, index);\n\t\t\tconst value = input.slice(index + separator.length);\n\t\t\treturn Option.some([key, value] as const);\n\t\t}\n\n\t\treturn Option.none;\n\t}\n}\n","import type { Parameter } from '../lexer/streams/ParameterStream';\n\n/**\n * Joins the parameters by their `leading` value, using the `value` property.\n * @seealso {@link joinRaw} for the version using `raw` instead of `value`.\n * @param parameters The parameters to join.\n * @returns The result of joining the parameters.\n */\nexport function join(parameters: readonly Parameter[]) {\n\tif (parameters.length === 0) return '';\n\tif (parameters.length === 1) return parameters[0].value;\n\n\tlet output = parameters[0].value;\n\tfor (let i = 1; i < parameters.length; i++) {\n\t\tconst parameter = parameters[i];\n\t\toutput += parameter.leading + parameter.value;\n\t}\n\n\treturn output;\n}\n\n/**\n * Joins the parameters by their `leading` value, using the `raw` property.\n * @seealso {@link join} for the version using `value` instead of `raw`.\n * @param parameters The parameters to join.\n * @returns The result of joining the parameters.\n */\nexport function joinRaw(parameters: readonly Parameter[]) {\n\tif (parameters.length === 0) return '';\n\tif (parameters.length === 1) return parameters[0].raw;\n\n\tlet output = parameters[0].raw;\n\tfor (let i = 1; i < parameters.length; i++) {\n\t\tconst parameter = parameters[i];\n\t\toutput += parameter.leading + parameter.raw;\n\t}\n\n\treturn output;\n}\n"]}