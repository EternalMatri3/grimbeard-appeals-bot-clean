{"version":3,"sources":["../../../result/src/lib/common/utils.ts","../../../result/src/lib/OptionError.ts","../../../result/src/lib/ResultError.ts","../../../result/src/lib/Result.ts","../../../result/src/lib/Option.ts","../../src/lib/ArgumentStream.ts","../../src/lib/lexer/streams/parameters/BaseParameter.ts","../../src/lib/lexer/streams/parameters/QuotedParameter.ts","../../src/lib/lexer/streams/parameters/WordParameter.ts","../../src/lib/lexer/streams/raw/TokenStream.ts","../../src/lib/lexer/streams/ParameterStream.ts","../../src/lib/lexer/Lexer.ts","../../src/lib/parser/ParserResult.ts","../../src/lib/parser/strategies/EmptyStrategy.ts","../../src/lib/parser/Parser.ts","../../src/lib/parser/strategies/PrefixedStrategy.ts","../../src/lib/util/util.ts"],"names":["__name","_a","__publicField","value","ValueProperty","_b","resolve","TokenType"],"mappings":"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","file":"index.global.js","sourcesContent":["export type Awaitable<T> = PromiseLike<T> | T;\n\nexport type If<Value extends boolean, TrueResult, FalseResult> = Value extends true\n\t? TrueResult\n\t: Value extends false\n\t\t? FalseResult\n\t\t: TrueResult | FalseResult;\n\nexport function isFunction<A extends readonly any[], R>(cb: (...args: A) => R): true;\nexport function isFunction(input: any): input is (...args: readonly any[]) => any;\nexport function isFunction(input: any) {\n\treturn typeof input === 'function';\n}\n\nexport function isPromise<T>(input: PromiseLike<T>): true;\nexport function isPromise(input: any): input is PromiseLike<any>;\nexport function isPromise(input: any) {\n\treturn typeof input === 'object' && input !== null && typeof input.then === 'function';\n}\n\nexport function returnThis<U>(this: U): U {\n\treturn this;\n}\n","export class OptionError extends Error {\n\tpublic override get name(): string {\n\t\treturn this.constructor.name;\n\t}\n}\n","export class ResultError<E> extends Error {\n\tpublic readonly value: E;\n\n\tpublic constructor(message: string, value: E) {\n\t\tsuper(message);\n\t\tthis.value = value;\n\t}\n\n\tpublic override get name(): string {\n\t\treturn this.constructor.name;\n\t}\n}\n","import { isFunction, returnThis, type Awaitable, type If } from './common/utils';\nimport { none, some, type None, type Option, type Some } from './Option';\nimport { ResultError } from './ResultError';\n\nconst ValueProperty = Symbol.for('@sapphire/result:Result.value');\nconst SuccessProperty = Symbol.for('@sapphire/result:Result.success');\n\n/**\n * A type used to express computations that can fail, it can be used for returning and propagating errors. This is a\n * type union with the variants `Ok(T)`, representing success and containing a value, and `Err(E)`, representing error\n * and containing an error value.\n *\n * @typeparam T The result's type.\n * @typeparam E The error's type.\n *\n * @see {@link https://doc.rust-lang.org/std/result/index.html}\n */\nexport class Result<T, E, const Success extends boolean = boolean> {\n\t/**\n\t * Branded value to ensure `Success` is typed correctly.\n\t * @internal\n\t */\n\tdeclare protected __STATUS__: Success;\n\n\tprivate readonly [ValueProperty]: If<Success, T, E>;\n\tprivate readonly [SuccessProperty]: Success;\n\n\tprivate constructor(value: If<Success, T, E>, success: Success) {\n\t\tthis[ValueProperty] = value;\n\t\tthis[SuccessProperty] = success;\n\t}\n\n\t/**\n\t * Returns `true` if the result is `Ok`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(-3);\n\t * assert.equal(x.isOk(), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Some error message');\n\t * assert.equal(x.isOk(), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_ok}\n\t */\n\tpublic isOk(): this is Ok<T, E> {\n\t\treturn this[SuccessProperty];\n\t}\n\n\t/**\n\t * Returns `true` if the result is `Ok` and the value inside of it matches a predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.isOkAnd((value) => value > 1), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = ok(0);\n\t * assert.equal(x.isOkAnd((value) => value > 1), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Some error message');\n\t * assert.equal(x.isOkAnd((value) => value > 1), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_ok_and}\n\t */\n\tpublic isOkAnd<R extends T>(cb: (value: T) => value is R): this is Ok<R, E>;\n\tpublic isOkAnd<R extends boolean>(cb: (value: T) => R): this is Ok<T, E> & R;\n\tpublic isOkAnd<R extends boolean>(cb: (value: T) => R): this is Ok<T, E> & R {\n\t\treturn this.isOk() && cb(this[ValueProperty]);\n\t}\n\n\t/**\n\t * Returns `true` if the result is `Err`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(-3);\n\t * assert.equal(x.isErr(), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Some error message');\n\t * assert.equal(x.isErr(), true);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_err}\n\t */\n\tpublic isErr(): this is Err<E, T> {\n\t\treturn !this[SuccessProperty];\n\t}\n\n\t/**\n\t * Returns `true` if the result is `Err` and the value inside of it matches a predicate.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.isErrAnd((error) => error instanceof TypeError), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err(new Error('Some error message'));\n\t * assert.equal(x.isErrAnd((error) => error instanceof TypeError), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err(new TypeError('Some error message'));\n\t * assert.equal(x.isErrAnd((error) => error instanceof TypeError), true);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_err_and}\n\t */\n\tpublic isErrAnd<R extends E>(cb: (error: E) => error is R): this is Err<R, T>;\n\tpublic isErrAnd<R extends boolean>(cb: (error: E) => R): this is Err<E, T> & R;\n\tpublic isErrAnd<R extends boolean>(cb: (error: E) => R): this is Err<E, T> & R {\n\t\treturn this.isErr() && cb(this[ValueProperty]);\n\t}\n\n\t/**\n\t * Converts from `Result<T, E>` to `Option<T>`.\n\t *\n\t * Converts itself into an `Option<T>`, and discarding the error, if any.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.ok(), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.ok(), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.ok}\n\t */\n\tpublic ok(): If<Success, Some<T>, None> {\n\t\treturn this.match({ ok: (value) => some(value), err: () => none });\n\t}\n\n\t/**\n\t * Converts from `Result<T, E>` to `Option<E>`.\n\t *\n\t * Converts itself into an `Option<E>`, and discarding the successful value, if any.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.err(), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.err(), 'Some error message');\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.err}\n\t */\n\tpublic err(): If<Success, None, Some<E>> {\n\t\treturn this.match({ ok: () => none, err: (error) => some(error) });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a contained `Ok` value, leaving an `Err` value\n\t * untouched.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.map((value) => value * 2), ok(4));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.map((value) => value * 2), err('Some error message'));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map}\n\t */\n\tpublic map<OutputValue>(cb: (value: If<Success, T, never>) => OutputValue): Result<OutputValue, E, Success> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.match({ ok: (value) => ok(cb(value)), err: returnThis });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Ok` value, leaving an `Err` value\n\t * untouched.\n\t *\n\t * Unlike {@link map}, this method does not wrap the returned value inside `Ok`, but instead, it returns the\n\t * returned value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.mapInto((value) => ok(value * value)), ok(4));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(0);\n\t * assert.equal(\n\t *   x.mapInto((value) => (value === 0 ? err('zero is not divisible') : ok(1 / value))),\n\t *   err('zero is not divisible')\n\t * );\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.mapInto((value) => ok(4)), err('Some error message'));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic mapInto<OutputResult extends AnyResult>(cb: (value: If<Success, T, never>) => OutputResult): If<Success, OutputResult, Err<E>> {\n\t\treturn this.match({ ok: (value) => cb(value), err: returnThis });\n\t}\n\n\t/**\n\t * Returns the provided default (if `Err`), or applies a function to the contained value (if `Ok`),\n\t *\n\t * Arguments passed to `mapOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use `mapOrElse`, which is lazily evaluated.\n\t * @param defaultValue The default value to use.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok('hello');\n\t * assert.equal(x.mapOr(42, (value) => value.length), 5);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Some error message');\n\t * assert.equal(x.mapOr(42, (value) => value.length), 42);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or}\n\t */\n\tpublic mapOr<MappedOutputValue, DefaultOutputValue>(\n\t\tdefaultValue: DefaultOutputValue,\n\t\tcb: (value: If<Success, T, never>) => MappedOutputValue\n\t): If<Success, MappedOutputValue, DefaultOutputValue> {\n\t\treturn this.match({ ok: (value) => cb(value), err: () => defaultValue });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `U` by applying fallback function default to a contained `Err` value, or function `cb`\n\t * to a contained `Ok` value.\n\t *\n\t * This function can be used to unpack a successful result while handling an error.\n\t * @param op The predicate that is run on `Err`.\n\t * @param cb The predicate that is run on `Ok`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<string, string> = ok('hello');\n\t * assert.equal(x.mapOrElse((error) => error.length, (value) => value.length), 5);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<string, string> = err('Some error message');\n\t * assert.equal(x.mapOrElse((error) => error.length, (value) => value.length), 18);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or_else}\n\t */\n\tpublic mapOrElse<OutputValue, OutputError>(\n\t\top: (error: If<Success, never, E>) => OutputError,\n\t\tcb: (value: If<Success, T, never>) => OutputValue\n\t): If<Success, OutputValue, OutputError> {\n\t\treturn this.match({ ok: (value) => cb(value), err: (error) => op(error) });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Err` value, leaving an `Ok` value\n\t * untouched.\n\t *\n\t * This function can be used to pass through a successful result while handling an error.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = ok(2);\n\t * assert.equal(x.mapErr((error) => error.message), ok(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = err(new Error('Some error message'));\n\t * assert.equal(x.mapErr((error) => error.message), err('Some error message'));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err}\n\t */\n\tpublic mapErr<OutputError>(cb: (error: If<Success, never, E>) => OutputError): Result<T, OutputError, Success> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.match({ ok: returnThis, err: (error) => err(cb(error)) });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Err` value, leaving an `Ok` value\n\t * untouched.\n\t *\n\t * This function can be used to pass through a successful result while handling an error.\n\t *\n\t * Unlike {@link mapErr}, this method does not wrap the returned value inside `Err`, but instead, it returns the\n\t * returned value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = ok(2);\n\t * assert.equal(x.mapErrInto((error) => err(error.message)), ok(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = err(new Error('Some error message'));\n\t * assert.equal(x.mapErrInto((error) => err(error.message)), err('Some error message'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = err(new Error('Some error message'));\n\t * assert.equal(x.mapErrInto((error) => ok(4)), ok(4));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic mapErrInto<OutputResult extends AnyResult>(cb: (error: If<Success, never, E>) => OutputResult): If<Success, Ok<T>, OutputResult> {\n\t\treturn this.match({ ok: returnThis, err: (error) => cb(error) });\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained value (if `Ok`).\n\t * @param cb The predicate.\n\t * @seealso {@link inspectAsync} for the awaitable version.\n\t *\n\t * @example\n\t * ```typescript\n\t * ok(2).inspect(console.log);\n\t * // Logs: 2\n\t * ```\n\t * @example\n\t * ```typescript\n\t * err('Some error message').inspect(console.log);\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.inspect}\n\t */\n\tpublic inspect(cb: (value: T) => unknown): this {\n\t\tif (this.isOk()) cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained value (if `Ok`) and awaits it.\n\t * @param cb The predicate.\n\t * @seealso {@link inspect} for the sync version.\n\t *\n\t * @example\n\t * ```typescript\n\t * await ok(2).inspectAsync(console.log);\n\t * // Logs: 2\n\t * ```\n\t * @example\n\t * ```typescript\n\t * await err('Some error message').inspectAsync(console.log);\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic async inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this> {\n\t\tif (this.isOk()) await cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained error (if `Err`).\n\t * @param cb The predicate.\n\t * @seealso {@link inspectErrAsync} for the awaitable version.\n\t *\n\t * @example\n\t * ```typescript\n\t * ok(2).inspectErr(console.log);\n\t * // Doesn't log\n\t * ```\n\t * @example\n\t * ```typescript\n\t * err('Some error message').inspectErr(console.log);\n\t * // Logs: Some error message\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.inspect_err}\n\t */\n\tpublic inspectErr(cb: (error: E) => unknown): this {\n\t\tif (this.isErr()) cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained error (if `Err`) and awaits it.\n\t * @param cb The predicate.\n\t * @seealso {@link inspectErr} for the sync version.\n\t *\n\t * @example\n\t * ```typescript\n\t * await ok(2).inspectErrAsync(console.log);\n\t * // Doesn't log\n\t * ```\n\t * @example\n\t * ```typescript\n\t * await err('Some error message').inspectErrAsync(console.log);\n\t * // Logs: Some error message\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic async inspectErrAsync(cb: (error: E) => Awaitable<unknown>): Promise<this> {\n\t\tif (this.isErr()) await cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an iterator over the possibly contained value.\n\t *\n\t * The iterator yields one value if the result is `Ok`, otherwise none.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(7);\n\t * for (const value of x.iter()) {\n\t *   console.log(value);\n\t * }\n\t * // Logs 7\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Nothing!');\n\t * for (const value of x.iter()) {\n\t *   console.log(value);\n\t * }\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.iter}\n\t */\n\tpublic *iter(): Generator<T> {\n\t\tif (this.isOk()) yield this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value.\n\t *\n\t * If the value is an `Err`, it throws a {@link ResultError} with the given message and the content of the `Err`.\n\t * @param message The message for the error.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.expect('Whoops!'), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.throws(() => x.expect('Whoops!'), {\n\t *   name: 'ResultError',\n\t *   message: 'Whoops',\n\t *   value: 'Emergency failure'\n\t * });\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.expect}\n\t */\n\tpublic expect(message: string): If<Success, T, never> {\n\t\tif (this.isErr()) throw new ResultError(message, this[ValueProperty]);\n\t\treturn this[ValueProperty] as If<Success, T, never>;\n\t}\n\n\t/**\n\t * Returns the contained `Err` value.\n\t *\n\t * If the value is an `Ok`, it throws a {@link ResultError} with the given message and the content of the `Ok`.\n\t * @param message The message for the error.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.throws(() => x.expectErr('Whoops!'), {\n\t *   name: 'ResultError',\n\t *   message: 'Whoops',\n\t *   value: 2\n\t * });\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.equal(x.expectErr('Whoops!'), 'Emergency failure');\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.expect_err}\n\t */\n\tpublic expectErr(message: string): If<Success, never, E> {\n\t\tif (this.isOk()) throw new ResultError(message, this[ValueProperty]);\n\t\treturn this[ValueProperty] as If<Success, never, E>;\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value.\n\t *\n\t * If the value is an `Err`, it throws a {@link ResultError} with the message, and the content of the `Err`.\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapOrElse}\n\t * @seealso {@link unwrapErr}\n\t * @seealso {@link unwrapRaw}\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.unwrap(), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.throws(() => x.unwrap(), {\n\t *   name: 'ResultError',\n\t *   message: 'Unwrap failed',\n\t *   value: 'Emergency failure'\n\t * });\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap}\n\t */\n\tpublic unwrap(): If<Success, T, never> {\n\t\tif (this.isErr()) throw new ResultError('Unwrap failed', this[ValueProperty]);\n\t\treturn this[ValueProperty] as If<Success, T, never>;\n\t}\n\n\t/**\n\t * Returns the contained `Err` value.\n\t *\n\t * If the value is an `Ok`, it throws a {@link ResultError} with the message, and the content of the `Ok`.\n\t * @seealso {@link unwrap}\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapOrElse}\n\t * @seealso {@link unwrapRaw}\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.throws(() => x.unwrapErr(), {\n\t *   name: 'ResultError',\n\t *   message: 'Unwrap failed',\n\t *   value: 2\n\t * });\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.equal(x.unwrapErr(), 'Emergency failure');\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_err}\n\t */\n\tpublic unwrapErr(): If<Success, never, E> {\n\t\tif (this.isOk()) throw new ResultError('Unwrap failed', this[ValueProperty]);\n\t\treturn this[ValueProperty] as If<Success, never, E>;\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value or the provided default.\n\t *\n\t * Arguments passed to `unwrapOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use {@link unwrapOrElse}, which is lazily evaluated.\n\t * @seealso {@link unwrap}\n\t * @seealso {@link unwrapOrElse}\n\t * @seealso {@link unwrapErr}\n\t * @seealso {@link unwrapRaw}\n\t *\n\t * @param defaultValue The default value.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(9);\n\t * assert.equal(x.unwrapOr(2), 9);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Error');\n\t * assert.equal(x.unwrapOr(2), 2);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or}\n\t */\n\tpublic unwrapOr<OutputValue>(defaultValue: OutputValue): If<Success, T, OutputValue> {\n\t\treturn this.match({ ok: (value) => value, err: () => defaultValue });\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value or computes it from a closure.\n\t * @seealso {@link unwrap}\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapErr}\n\t * @seealso {@link unwrapRaw}\n\t *\n\t * @param op The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const count = (x: string) => x.length;\n\t *\n\t * assert.equal(ok(2).unwrapOrElse(count), 2);\n\t * assert.equal(err('hello').unwrapOrElse(count), 5);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or_else}\n\t */\n\tpublic unwrapOrElse<OutputValue>(op: (error: E) => OutputValue): If<Success, T, OutputValue> {\n\t\treturn this.match({ ok: (value) => value, err: (error) => op(error) });\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value.\n\t *\n\t * If the value is an `Err`, it throws the contained error.\n\t * @seealso {@link unwrap}\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapOrElse}\n\t * @seealso {@link unwrapErr}\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.unwrapRaw(), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.throws(() => x.unwrapRaw(), {\n\t *   name: 'Error',\n\t *   message: 'Unwrap failed',\n\t *   value: 'Emergency failure'\n\t * });\n\t * ```\n\t */\n\tpublic unwrapRaw(): If<Success, T, never> {\n\t\t// eslint-disable-next-line @typescript-eslint/no-throw-literal\n\t\tif (this.isErr()) throw this[ValueProperty];\n\t\t// @ts-expect-error Complex types\n\t\treturn this[ValueProperty] as T;\n\t}\n\n\t/**\n\t * Returns `result` if the result is `Ok`, otherwise returns the `Err` value of itself.\n\t * @param result The result to check.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * const y: Result<string, string> = err('Late error');\n\t * assert.equal(x.and(y), err('Late error'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Early error');\n\t * const y: Result<string, string> = err('Late error');\n\t * assert.equal(x.and(y), err('Early error'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * const y: Result<string, string> = ok('Hello');\n\t * assert.equal(x.and(y), ok('Hello'));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and}\n\t */\n\tpublic and<OutputResult extends AnyResult>(result: OutputResult): If<Success, OutputResult, Err<E>> {\n\t\treturn this.match({ ok: () => result, err: returnThis });\n\t}\n\n\t/**\n\t * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.\n\t *\n\t * This function can be used for control flow based on `Result` values.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * function fractionOf4(value: number) {\n\t *   return value === 0 ? err('overflowed') : ok(4 / value);\n\t * }\n\t *\n\t * assert.equal(ok(2).andThen(fractionOf4), ok(4));\n\t * assert.equal(ok(0).andThen(fractionOf4), err('overflowed'));\n\t * assert.equal(err('not a number').andThen(fractionOf4), err('not a number'));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then}\n\t */\n\tpublic andThen<OutputResult extends AnyResult>(cb: (value: T) => OutputResult): If<Success, OutputResult, Err<E>> {\n\t\treturn this.match({ ok: (value) => cb(value), err: returnThis });\n\t}\n\n\t/**\n\t * Return `result` if the result is `Err`, otherwise returns the `Ok` value of self.\n\t *\n\t * Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended\n\t * to use {@link orElse}, which is lazily evaluated.\n\t * @param result The result to check.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * const y: Result<number, string> = err('Late error');\n\t * assert.equal(x.or(y), ok(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Early error');\n\t * const y: Result<number, string> = ok(2);\n\t * assert.equal(x.or(y), ok(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Early error');\n\t * const y: Result<number, string> = err('Late error');\n\t * assert.equal(x.or(y), err('Late error'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * const y: Result<number, string> = ok(100);\n\t * assert.equal(x.or(y), ok(2));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.or}\n\t */\n\tpublic or<OutputResult extends AnyResult>(result: OutputResult): If<Success, Ok<T>, OutputResult> {\n\t\treturn this.match({ ok: returnThis, err: () => result });\n\t}\n\n\t/**\n\t * Calls `cb` if the result is `Err`, otherwise returns the `Ok` value of self.\n\t *\n\t * This function can be used for control flow based on result values.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const square = (x: number): Result<number, string> => ok(x * x);\n\t * const wrapErr = (x: number): Result<number, string> => err(x);\n\t *\n\t * assert.equal(ok(2).orElse(square).orElse(square), ok(2));\n\t * assert.equal(ok(2).orElse(wrapErr).orElse(square), ok(2));\n\t * assert.equal(err(3).orElse(square).orElse(wrapErr), ok(9));\n\t * assert.equal(err(3).orElse(wrapErr).orElse(wrapErr), err(3));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.or_else}\n\t */\n\tpublic orElse<OutputResult extends AnyResult>(cb: (error: E) => OutputResult): If<Success, Ok<T>, OutputResult> {\n\t\treturn this.match({ ok: returnThis, err: (error) => cb(error) });\n\t}\n\n\t/**\n\t * Returns `true` if the result is an `Ok` and the given value strict equals it.\n\t * @param value The value to compare.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.contains(2), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(3);\n\t * assert.equal(x.contains(2), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.contains(2), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.contains}\n\t */\n\tpublic contains<const Value extends T>(this: Ok<T>, value: Value): this is Ok<Value>;\n\tpublic contains(this: Err<E>, value: T): false;\n\tpublic contains(value: T): boolean {\n\t\treturn this.isOkAnd((inner) => inner === value);\n\t}\n\n\t/**\n\t * Returns `true` if the result is an `Err` and the given error strict equals it.\n\t * @param error The error to compare.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.containsErr('Some error message'), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.containsErr('Some error message'), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some other error message');\n\t * assert.equal(x.containsErr('Some error message'), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.contains_err}\n\t */\n\tpublic containsErr(this: Ok<T>, error: E): false;\n\tpublic containsErr<const Value extends E>(this: Err<E>, error: Value): this is Err<Value>;\n\tpublic containsErr(error: E): boolean {\n\t\treturn this.isErrAnd((inner) => inner === error);\n\t}\n\n\t/**\n\t * Transposes a `Result` of an `Option` into an `Option` of a `Result`.\n\t *\n\t * `ok(none)` will be mapped to `none`. `ok(some(v))` and `err(e)` will be mapped to `some(ok(v))` and `some(err(e))`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<Option<number>, Error> = ok(some(5));\n\t * const y: Option<Result<number, Error>> = some(ok(5));\n\t * assert.equal(x.transpose(), y);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.transpose}\n\t */\n\tpublic transpose<InnerValue>(this: Result<Option<InnerValue>, E, Success>): If<Success, Option<Ok<InnerValue>>, Some<Err<E>>> {\n\t\treturn this.match({\n\t\t\tok: (value) => value.map((value) => ok(value)),\n\t\t\terr() {\n\t\t\t\treturn some(this);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Converts from `Result<Result<T, E>, E>` to `Result<T, E>`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<Result<string, number>, number> = ok(ok('Hello'));\n\t * assert.equal(x.flatten(), ok('Hello'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<Result<string, number>, number> = ok(err(6));\n\t * assert.equal(x.flatten(), err(6));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<Result<string, number>, number> = err(6);\n\t * assert.equal(x.flatten(), err(6));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.flatten}\n\t */\n\tpublic flatten<InnerResult extends AnyResult>(this: Result<InnerResult, E, Success>): If<Success, InnerResult, Err<E>> {\n\t\treturn this.match({ ok: (value) => value, err: returnThis });\n\t}\n\n\t/**\n\t * Returns the `Ok` value if self is `Ok`, and the `Err` value if self is `Err`.\n\t *\n\t * @example\n\t * ```typescript\n\t * let x: Result<number, number> = ok(3);\n\t * assert.equal(x.intoOkOrErr(), 3);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * let x: Result<number, number> = err(4);\n\t * assert.equal(x.intoOkOrErr(), 4);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.into_ok_or_err}\n\t */\n\tpublic intoOkOrErr(): If<Success, T, E> {\n\t\treturn this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns a `Promise` object with the awaited value (if `Ok`) or the awaited error (if `Err`).\n\t *\n\t * @example\n\t * ```typescript\n\t * let x = ok(Promise.resolve(3));\n\t * assert.equal(await x.intoPromise(), ok(3));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic intoPromise(): Promise<If<Success, Ok<Awaited<T>>, Err<Awaited<E>>>> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.match<Ok<Awaited<T>>, Err<Awaited<E>>>({\n\t\t\t// @ts-expect-error Complex types\n\t\t\tok: async (value) => ok(await value), // NOSONAR\n\t\t\t// @ts-expect-error Complex types\n\t\t\terr: async (error) => err(await error) // NOSONAR\n\t\t});\n\t}\n\n\t/**\n\t * Checks whether or not `other` equals with self.\n\t * @param other The other result to compare.\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#tymethod.eq}\n\t */\n\tpublic eq<OtherValue extends T, OtherError extends E, OtherSuccess extends boolean>(\n\t\tother: Result<OtherValue, OtherError, OtherSuccess>\n\t): this is Result<OtherValue, OtherError, OtherSuccess> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isOk() === other.isOk() && this[ValueProperty] === other[ValueProperty];\n\t}\n\n\t/**\n\t * Checks whether or not `other` doesn't equal with self.\n\t * @param other The other result to compare.\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#method.ne}\n\t */\n\tpublic ne(other: Result<T, E>): boolean {\n\t\treturn !this.eq(other);\n\t}\n\n\t/**\n\t * Runs `ok` function if self is `Ok`, otherwise runs `err` function.\n\t * @param branches The branches to match.\n\t *\n\t * @example\n\t * ```typescript\n\t * const result = ok(4).match({\n\t *   ok: (v) => v,\n\t *   err: () => 0\n\t * });\n\t * assert.equal(result, 4);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const result = err('Hello').match({\n\t *   ok: (v) => v,\n\t *   err: () => 0\n\t * });\n\t * assert.equal(result, 0);\n\t * ```\n\t */\n\tpublic match<OkValue, ErrValue>(branches: {\n\t\tok(this: Ok<T>, value: If<Success, T, never>): OkValue;\n\t\terr(this: Err<E>, error: If<Success, never, E>): ErrValue;\n\t}): If<Success, OkValue, ErrValue> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isOk() ? branches.ok.call(this, this[ValueProperty]) : branches.err.call(this, this[ValueProperty] as E);\n\t}\n\n\t/**\n\t * Returns an iterator over the possibly contained value.\n\t *\n\t * The iterator yields one value if the result is `Ok`, otherwise none.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(7);\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Logs 7\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Nothing!');\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link IResult.iter}\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.iter}\n\t */\n\tpublic [Symbol.iterator](): Generator<T> {\n\t\treturn this.iter();\n\t}\n\n\tpublic get [Symbol.toStringTag](): If<Success, 'Ok', 'Err'> {\n\t\treturn this.match({ ok: () => 'Ok', err: () => 'Err' });\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static ok<T = undefined, E = any>(this: void, value?: T): Ok<T, E>;\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static ok<T, E = any>(this: void, value: T): Ok<T, E> {\n\t\treturn new Result<T, E, true>(value, true);\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static err<E = undefined, T = any>(this: void, value?: E): Err<E, T>;\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static err<E, T = any>(this: void, value: E): Err<E, T> {\n\t\treturn new Result<T, E, false>(value, false);\n\t}\n\n\t/**\n\t * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object. This override\n\t * exists to interoperate with other versions of this class, such as the one coming from another version of this\n\t * library or from a different build.\n\t *\n\t * @param instance The instance to check.\n\t * @returns Whether or not the instance is a `Result`.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Result } from '@sapphire/result';\n\t * const { ok } = require('@sapphire/result');\n\t *\n\t * ok(2) instanceof Result; // true\n\t * ```\n\t */\n\tpublic static [Symbol.hasInstance](instance: unknown): boolean {\n\t\treturn typeof instance === 'object' && instance !== null && ValueProperty in instance && SuccessProperty in instance;\n\t}\n\n\t/**\n\t * @deprecated Use {@link Result.isResult} instead.\n\t *\n\t * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object.\n\t *\n\t * @param instance The instance to check.\n\t * @returns true if the instance is a `Result` or a `Result`-like object, false otherwise.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Result } from '@sapphire/result';\n\t * const { ok } = require('@sapphire/result');\n\t *\n\t * Result.isResult(ok(2)); // true\n\t * ```\n\t */\n\tpublic static is(instance: unknown): instance is AnyResult {\n\t\treturn Result[Symbol.hasInstance](instance);\n\t}\n\n\t/**\n\t * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object.\n\t *\n\t * @param instance The instance to check.\n\t * @returns true if the instance is a `Result` or a `Result`-like object, false otherwise.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Result } from '@sapphire/result';\n\t * const { ok } = require('@sapphire/result');\n\t *\n\t * Result.isResult(ok(2)); // true\n\t * ```\n\t */\n\tpublic static isResult(instance: unknown): instance is AnyResult {\n\t\treturn Result[Symbol.hasInstance](instance);\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a callback.\n\t *\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static from<T, E = unknown>(this: void, op: ResultResolvable<T, E> | (() => ResultResolvable<T, E>)): Result<T, E> {\n\t\ttry {\n\t\t\treturn resolve(isFunction(op) ? op() : op);\n\t\t} catch (error) {\n\t\t\treturn err(error as E);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a promise or async callback.\n\t *\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\tpublic static async fromAsync<T, E = unknown>(\n\t\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\t\tthis: void,\n\t\top: Awaitable<ResultResolvable<T, E>> | (() => Awaitable<ResultResolvable<T, E>>)\n\t): Promise<Result<T, E>> {\n\t\ttry {\n\t\t\treturn resolve(await (isFunction(op) ? op() : op));\n\t\t} catch (error) {\n\t\t\treturn err(error as E);\n\t\t}\n\t}\n\n\t/**\n\t * Creates an {@link Ok} that is the combination of all collected {@link Ok} values as an array, or the first\n\t * {@link Err} encountered.\n\t *\n\t * @param results An array of {@link Result}s.\n\t * @returns A new {@link Result}.\n\t */\n\tpublic static all<const Entries extends readonly AnyResult[]>(\n\t\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\t\tthis: void,\n\t\tresults: Entries\n\t): Result<UnwrapOkArray<Entries>, UnwrapErrArray<Entries>[number]> {\n\t\tconst values: unknown[] = [];\n\t\tfor (const result of results) {\n\t\t\tif (result.isErr()) return result;\n\n\t\t\tvalues.push(result[ValueProperty]);\n\t\t}\n\n\t\treturn ok(values as UnwrapOkArray<Entries>);\n\t}\n\n\t/**\n\t * Returns the first encountered {@link Ok}, or an {@link Err} that is the combination of all collected error values.\n\t *\n\t * @param results An array of {@link Result}s.\n\t * @returns A new {@link Result}.\n\t */\n\tpublic static any<const Entries extends readonly AnyResult[]>(\n\t\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\t\tthis: void,\n\t\tresults: Entries\n\t): Result<UnwrapOk<Entries[number]>, UnwrapErrArray<Entries>> {\n\t\tconst errors: unknown[] = [];\n\t\tfor (const result of results) {\n\t\t\tif (result.isOk()) return result;\n\n\t\t\terrors.push(result[ValueProperty]);\n\t\t}\n\n\t\treturn err(errors as UnwrapErrArray<Entries>);\n\t}\n}\n\nexport namespace Result {\n\texport type Ok<T, E = any> = Result<T, E, true>;\n\texport type Err<E, T = any> = Result<T, E, false>;\n\texport type Any = Result<any, any>;\n\texport type Resolvable<T, E = any, Success extends boolean = boolean> = T | Result<T, E, Success>;\n\texport type UnwrapOk<T extends AnyResult> = T extends Ok<infer S> ? S : never;\n\texport type UnwrapErr<T extends AnyResult> = T extends Err<infer S> ? S : never;\n\n\texport type UnwrapOkArray<T extends readonly AnyResult[] | []> = {\n\t\t-readonly [P in keyof T]: UnwrapOk<T[P]>;\n\t};\n\texport type UnwrapErrArray<T extends readonly AnyResult[] | []> = {\n\t\t-readonly [P in keyof T]: UnwrapErr<T[P]>;\n\t};\n}\n\nexport const { ok, err } = Result;\n\nfunction resolve<T, E>(value: Result.Resolvable<T, E>): Result<T, E> {\n\treturn Result.isResult(value) ? value : ok(value);\n}\n\nexport type ResultResolvable<T, E = any, Success extends boolean = boolean> = Result.Resolvable<T, E, Success>;\n\nexport type Ok<T, E = any> = Result.Ok<T, E>;\nexport type Err<E, T = any> = Result.Err<E, T>;\nexport type AnyResult = Result.Any;\n\nexport type UnwrapOk<T extends AnyResult> = Result.UnwrapOk<T>;\nexport type UnwrapErr<T extends AnyResult> = Result.UnwrapErr<T>;\n\nexport type UnwrapOkArray<T extends readonly AnyResult[] | []> = Result.UnwrapOkArray<T>;\nexport type UnwrapErrArray<T extends readonly AnyResult[] | []> = Result.UnwrapErrArray<T>;\n","import { isFunction, returnThis, type Awaitable, type If } from './common/utils';\nimport { OptionError } from './OptionError';\nimport { err, ok, Result, type Err, type Ok } from './Result';\n\nconst ValueProperty = Symbol.for('@sapphire/result:Option.value');\nconst ExistsProperty = Symbol.for('@sapphire/result:Option.exists');\n\nexport class Option<T, Exists extends boolean = boolean> {\n\t/**\n\t * Branded value to ensure `Success` is typed correctly.\n\t * @internal\n\t */\n\tdeclare protected __STATUS__: Exists;\n\n\tprivate readonly [ValueProperty]: If<Exists, T, null>;\n\tprivate readonly [ExistsProperty]: Exists;\n\n\tprivate constructor(value: If<Exists, T, null>, exists: Exists) {\n\t\tthis[ValueProperty] = value;\n\t\tthis[ExistsProperty] = exists;\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `Some` value.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.isSome(), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.isSome(), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some}\n\t */\n\tpublic isSome(): this is Some<T> {\n\t\treturn this[ExistsProperty];\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `Some` and the value inside of it matches a predicate.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.isSomeAnd((x) => x > 1), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(0);\n\t * assert.equal(x.isSomeAnd((x) => x > 1), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.isSomeAnd((x) => x > 1), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some_and}\n\t */\n\tpublic isSomeAnd<R extends T>(cb: (value: T) => value is R): this is Some<R>;\n\tpublic isSomeAnd<R extends boolean>(cb: (value: T) => R): this is Some<R> & R;\n\tpublic isSomeAnd<R extends boolean>(cb: (value: T) => R): this is Some<R> & R {\n\t\treturn this.isSome() && cb(this[ValueProperty]);\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `None` value.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.isNone(), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.isNone(), true);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_none}\n\t */\n\tpublic isNone(): this is None {\n\t\treturn !this[ExistsProperty];\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `None` value or the value inside of it matches a predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.isNoneOr((x) => x > 1), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(0);\n\t * assert.equal(x.isNoneOr((x) => x > 1), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.isNoneOr((x) => x > 1), true);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_none_or}\n\t */\n\tpublic isNoneOr<R extends T>(cb: (value: T) => value is R): this is None | Some<R>;\n\tpublic isNoneOr<R extends boolean>(cb: (value: T) => R): If<Exists, R, true>;\n\tpublic isNoneOr<R extends boolean>(cb: (value: T) => R): If<Exists, R, true> {\n\t\treturn this.match({ some: (value) => cb(value), none: () => true });\n\t}\n\n\t/**\n\t * Returns the contained `Some` value.\n\t * @param message The message for the error.\n\t * If the value is an `Err`, it throws an {@link OptionError} with the given message.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some(2);\n\t * assert.equal(x.expect('Whoops!'), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.throws(() => x.expect('Whoops!'), {\n\t *   name: 'OptionError',\n\t *   message: 'Whoops'\n\t * });\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.expect}\n\t */\n\tpublic expect(message: string): If<Exists, T, never> {\n\t\tif (this.isNone()) throw new OptionError(message);\n\t\t// @ts-expect-error Complex types\n\t\treturn this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns the contained `Some` value.\n\t *\n\t * If the value is an `Err`, it throws an {@link OptionError} with the message.\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapOrElse}\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some(2);\n\t * assert.equal(x.unwrap(), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.throws(() => x.unwrap(), {\n\t *   name: 'OptionError',\n\t *   message: 'Unwrap failed'\n\t * });\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap}\n\t */\n\tpublic unwrap(): If<Exists, T, never> {\n\t\tif (this.isNone()) throw new OptionError('Unwrap failed');\n\t\t// @ts-expect-error Complex types\n\t\treturn this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns the contained `Some` value or a provided default.\n\t *\n\t * Arguments passed to `unwrapOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use {@link unwrapOrElse}, which is lazily evaluated.\n\t *\n\t * @example\n\t * ```typescript\n\t * assert.equal(some(2).unwrapOr(0), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * assert.equal(none.unwrapOr(0), 0);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or}\n\t */\n\tpublic unwrapOr<OutputValue>(defaultValue: OutputValue): If<Exists, T, OutputValue> {\n\t\treturn this.match({ some: (value) => value, none: () => defaultValue });\n\t}\n\n\t/**\n\t * Returns the contained Some value or computes it from a closure.\n\t *\n\t * @example\n\t * ```typescript\n\t * assert.equal(some(2).unwrapOrElse(() => 0), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * assert.equal(none.unwrapOrElse(() => 0), 0);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else}\n\t */\n\tpublic unwrapOrElse<OutputValue>(cb: () => OutputValue): If<Exists, T, OutputValue> {\n\t\treturn this.match({ some: (value) => value, none: cb });\n\t}\n\n\t/**\n\t * Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const maybeSomeString = some('Hello, world!');\n\t * const maybeSomeLength = maybeSomeString.map((value) => value.length);\n\t *\n\t * assert.equal(maybeSomeLength, some(13));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map}\n\t */\n\tpublic map<U>(cb: (value: T) => U): If<Exists, Some<U>, None> {\n\t\treturn this.match({ some: (value) => some(cb(value)), none: returnThis });\n\t}\n\n\t/**\n\t * Maps a `Some<T>` to the returned `Option<U>` by applying a function to a contained value, leaving `None`\n\t * untouched.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const input: Option<string> = some('Hello, world!');\n\t * const result = input.mapInto((value) => some(value.length));\n\t *\n\t * assert.equal(result, some(13));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const input: Option<string> = none;\n\t * const result = input.mapInto((value) => some(value.length));\n\t *\n\t * assert.equal(result, none);\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic mapInto<OutputOption extends AnyOption>(cb: (value: T) => OutputOption): If<Exists, OutputOption, None> {\n\t\treturn this.match({ some: (value) => cb(value), none: returnThis });\n\t}\n\n\t/**\n\t * Returns the provided default result (if none), or applies a function to the contained value (if any).\n\t *\n\t * Arguments passed to `mapOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use {@link mapOrElse}, which is lazily evaluated.\n\t * @param defaultValue The default value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some('hello');\n\t * assert.equal(x.mapOr(42, (value) => value.length), 5);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.equal(x.mapOr(42, (value) => value.length), 42);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or}\n\t */\n\tpublic mapOr<MappedOutputValue, DefaultOutputValue>(\n\t\tdefaultValue: DefaultOutputValue,\n\t\tcb: (value: T) => MappedOutputValue\n\t): If<Exists, MappedOutputValue, DefaultOutputValue> {\n\t\treturn this.match({ some: (value) => cb(value), none: () => defaultValue });\n\t}\n\n\t/**\n\t * Computes a default function result (if none), or applies a different function to the contained value (if any).\n\t * @param defaultValue The default value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some('hello');\n\t * assert.equal(x.mapOrElse(() => 42, (value) => value.length), 5);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.equal(x.mapOrElse(() => 42, (value) => value.length), 42);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or_else}\n\t */\n\tpublic mapOrElse<OutputValue, OutputNone>(defaultValue: () => OutputNone, cb: (value: T) => OutputValue): If<Exists, OutputValue, OutputNone> {\n\t\treturn this.match({ some: (value) => cb(value), none: () => defaultValue() });\n\t}\n\n\t/**\n\t * Maps a `None` to the returned `Option<U>` by applying a function to a contained value, leaving `Some<T>`\n\t * untouched.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const input: Option<string> = some('Hello, world!');\n\t * const result = input.mapNoneInto(() => some(13));\n\t *\n\t * assert.equal(result, some('Hello, world!'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const input: Option<string> = none;\n\t * const result = input.mapNoneInto(() => some(13));\n\t *\n\t * assert.equal(result, some(13));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic mapNoneInto<OutputOption extends AnyOption>(cb: () => OutputOption): If<Exists, Some<T>, OutputOption> {\n\t\treturn this.match({ some: returnThis, none: cb });\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained value (if `Some`).\n\t * @param cb The predicate.\n\t * @seealso {@link inspectAsync} for the awaitable version.\n\t *\n\t * @example\n\t * ```typescript\n\t * some(2).inspect(console.log);\n\t * // Logs: 2\n\t * ```\n\t * @example\n\t * ```typescript\n\t * none.inspect(console.log);\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.inspect}\n\t */\n\tpublic inspect(cb: (value: T) => void): this {\n\t\tif (this.isSome()) cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained value (if `Some`).\n\t * @param cb The predicate.\n\t * @seealso {@link inspect} for the sync version.\n\t *\n\t * @example\n\t * ```typescript\n\t * await some(2).inspectAsync(console.log);\n\t * // Logs: 2\n\t * ```\n\t * @example\n\t * ```typescript\n\t * await none.inspectAsync(console.log);\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic async inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this> {\n\t\tif (this.isSome()) await cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to `Ok(v)` and `None` to `Err(err)`.\n\t *\n\t * Arguments passed to `okOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use {@link okOrElse}, which is lazily evaluated.\n\t * @param err The error to be used.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some('hello');\n\t * assert.equal(x.okOr(0), ok('hello'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.equal(x.okOr(0), err(0));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or}\n\t */\n\tpublic okOr<ErrorValue>(error: ErrorValue): If<Exists, Ok<T>, Err<ErrorValue>> {\n\t\treturn this.match({ some: (value) => ok(value), none: () => err(error) });\n\t}\n\n\t/**\n\t * Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to `Ok(v)` and `None` to `Err(err())`.\n\t * @param cb The error to be used.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some('hello');\n\t * assert.equal(x.okOrElse(() => 0), ok('hello'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.equal(x.okOrElse(() => 0), err(0));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or_else}\n\t */\n\tpublic okOrElse<ErrorValue>(cb: () => ErrorValue): If<Exists, Ok<T>, Err<ErrorValue>> {\n\t\treturn this.match({ some: (value) => ok(value), none: () => err(cb()) });\n\t}\n\n\t/**\n\t * Returns an iterator over the possibly contained value.\n\t *\n\t * The iterator yields one value if the result is `Some`, otherwise none.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = some(7);\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Logs 7\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = none;\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link Option.iter}\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.iter}\n\t */\n\tpublic *iter(): Generator<T> {\n\t\tif (this.isSome()) yield this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns `None` if the option is `None`, otherwise returns `option`.\n\t * @param option The option.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<string> = none;\n\t * assert.equal(x.and(y), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<string> = some('foo');\n\t * assert.equal(x.and(y), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<string> = some('foo');\n\t * assert.equal(x.and(y), some('foo'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<string> = none;\n\t * assert.equal(x.and(y), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.and}\n\t */\n\tpublic and<OutputOption extends AnyOption>(option: OutputOption): If<Exists, OutputOption, None> {\n\t\treturn this.match({ some: () => option, none: returnThis });\n\t}\n\n\t/**\n\t * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.\n\t *\n\t * This function can be used for control flow based on `Result` values.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * function fractionOf4(value: number) {\n\t *   return value === 0 ? none : some(4 / value);\n\t * }\n\t *\n\t * assert.equal(some(2).andThen(fractionOf4), some(4));\n\t * assert.equal(some(0).andThen(fractionOf4), none);\n\t * assert.equal(none.andThen(fractionOf4), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then}\n\t */\n\tpublic andThen<OutputOption extends AnyOption>(cb: (value: T) => OutputOption): If<Exists, OutputOption, None> {\n\t\treturn this.match({ some: (value) => cb(value), none: returnThis });\n\t}\n\n\t/**\n\t * Returns the option if it contains a value, otherwise returns `option`.\n\t * @param option The option.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<number> = none;\n\t * assert.equal(x.or(y), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<number> = some(100);\n\t * assert.equal(x.or(y), some(100));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<number> = some(100);\n\t * assert.equal(x.or(y), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<number> = none;\n\t * assert.equal(x.or(y), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.or}\n\t */\n\tpublic or<OutputOption extends AnyOption>(option: OutputOption): If<Exists, Some<T>, OutputOption> {\n\t\treturn this.match({ some: returnThis, none: () => option });\n\t}\n\n\t/**\n\t * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.\n\t *\n\t * This function can be used for control flow based on `Result` values.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const nobody = (): Option<string> => none;\n\t * const vikings = (): Option<string> => some('vikings');\n\t *\n\t * assert.equal(some('barbarians').orElse(vikings), some('barbarians'));\n\t * assert.equal(none.orElse(vikings), some('vikings'));\n\t * assert.equal(none.orElse(nobody), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.or_else}\n\t */\n\tpublic orElse<OutputOption extends AnyOption>(cb: () => OutputOption): If<Exists, Some<T>, OutputOption> {\n\t\treturn this.match({ some: returnThis, none: () => cb() });\n\t}\n\n\t/**\n\t * Returns `Some` if exactly one of self or `option` is `Some`, otherwise returns `None`.\n\t * @param option The option to compare.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<number> = none;\n\t * assert.equal(x.xor(y), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<number> = some(2);\n\t * assert.equal(x.xor(y), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<number> = some(2);\n\t * assert.equal(x.xor(y), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<number> = none;\n\t * assert.equal(x.xor(y), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.xor}\n\t */\n\tpublic xor<OtherValue, OtherExists extends boolean>(\n\t\toption: Option<OtherValue, OtherExists>\n\t): If<Exists, If<OtherExists, None, Some<T>>, Option<OtherValue, OtherExists>> {\n\t\treturn this.match<If<OtherExists, None, Some<T>>, Option<OtherValue, OtherExists>>({\n\t\t\tsome() {\n\t\t\t\treturn (option.isNone() ? this : none) as If<OtherExists, None, Some<T>>;\n\t\t\t},\n\t\t\tnone: () => option\n\t\t});\n\t}\n\n\t/**\n\t * Returns None if the option is None, otherwise calls `predicate` with the wrapped value and returns:\n\t *\n\t * - `Some(t)` if `predicate` returns `true` (where t is the wrapped value), and\n\t * - `None` if `predicate` returns `false`.\n\t * @param predicate The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * function isEven(value: number) {\n\t *   return n % 2 === 0;\n\t * }\n\t *\n\t * assert.equal(none.filter(isEven), none);\n\t * assert.equal(some(3).filter(isEven), none);\n\t * assert.equal(some(4).filter(isEven), some(4));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.filter}\n\t */\n\tpublic filter<R extends T>(predicate: (value: T) => value is R): Option<R>;\n\tpublic filter(predicate: (value: T) => boolean): Option<T>;\n\tpublic filter(predicate: (value: T) => boolean): Option<T> {\n\t\treturn this.isSomeAnd(predicate) ? this : none;\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `Some` value containing the given value.\n\t * @param value The value to compare.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.contains(2), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(3);\n\t * assert.equal(x.contains(2), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.contains(2), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.contains}\n\t */\n\tpublic contains<const Value extends T>(value: If<Exists, Value, unknown>): this is Some<Value> {\n\t\treturn this.isSomeAnd((inner) => inner === value);\n\t}\n\n\t/**\n\t * Zips self with another `Option`.\n\t *\n\t * If self is `Some(s)` and `other` is `Some(o)`, this method returns `Some([s, o])`. Otherwise, `None` is returned.\n\t * @param other The option to zip self with.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = some(1);\n\t * const y = some('hi');\n\t * const z = none;\n\t *\n\t * assert.equal(x.zip(y), some([1, 'hi']));\n\t * assert.equal(x.zip(z), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.zip}\n\t */\n\tpublic zip<OtherValue, OtherExists extends boolean>(\n\t\tother: Option<OtherValue, OtherExists>\n\t): Option<[T, OtherValue], If<Exists, OtherExists, false>> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isSome() && other.isSome() ? some([this[ValueProperty], other[ValueProperty]] as [T, OtherValue]) : none;\n\t}\n\n\t/**\n\t * Zips self and another `Option` with function `f`.\n\t *\n\t * If self is `Some(s)` and other is `Some(o)`, this method returns `Some(f(s, o))`. Otherwise, `None` is returned.\n\t * @param other The option to zip self with.\n\t * @param f The function that computes the returned value.\n\t *\n\t * @example\n\t * ```typescript\n\t * class Point {\n\t *   public readonly x: number;\n\t *   public readonly y: number;\n\t *\n\t *   public constructor(x: number, y: number) {\n\t *     this.x = x;\n\t *     this.y = y;\n\t *   }\n\t * }\n\t *\n\t * const x = some(17.5);\n\t * const y = some(42.7);\n\t *\n\t * assert.equal(x.zipWith(y, (s, o) => new Point(s, o)), some(new Point(17.5, 42.7)));\n\t * assert.equal(x.zipWith(none, (s, o) => new Point(s, o)), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.zip_with}\n\t */\n\tpublic zipWith<OtherValue, OtherExists extends boolean, ReturnValue>(\n\t\tother: Option<OtherValue, OtherExists>,\n\t\tf: (value0: T, value1: OtherValue) => ReturnValue\n\t): Option<ReturnValue, If<Exists, OtherExists, false>> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isSome() && other.isSome() ? some(f(this[ValueProperty], other[ValueProperty])) : none;\n\t}\n\n\t/**\n\t * Unzips an option containing a tuple of two options.\n\t *\n\t * If self is `Some([a, b])` this method returns `[Some(a), Some(b)]`. Otherwise, `[None, None]` is returned.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<[number, string]> = some([1, 'hi']);\n\t * assert.equal(x.unzip(), [some(1), some('hi')]);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<[number, string]> = none;\n\t * assert.equal(x.unzip(), [none, none]);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unzip}\n\t */\n\tpublic unzip<Value0, Value1, Exists extends boolean>(\n\t\tthis: Option<readonly [Value0, Value1], Exists>\n\t): [Option<Value0, Exists>, Option<Value1, Exists>] {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.match({\n\t\t\tsome: ([value0, value1]) => [some(value0), some(value1)],\n\t\t\tnone: () => [none, none]\n\t\t});\n\t}\n\n\t/**\n\t * Transposes an `Option` of a `Result` into a `Result` of an `Option`.\n\t *\n\t * `none` will be mapped to `ok(none)`. `some(ok(v))` and `some(err(e))` will be mapped to `ok(some(v))` and `err(e)`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<Result<number, Error>> = some(ok(5));\n\t * const y: Result<Option<number>, Error> = ok(some(5));\n\t * assert.equal(x.transpose(), y);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.transpose}\n\t */\n\tpublic transpose<ResultValue, ResultError, ResultSuccess extends boolean, Exists extends boolean>(\n\t\tthis: Option<Result<ResultValue, ResultError, ResultSuccess>, Exists>\n\t): If<Exists, Result<Some<ResultValue>, ResultError, ResultSuccess>, Ok<None>> {\n\t\treturn this.match<Result<Some<ResultValue>, ResultError, ResultSuccess>, Ok<None>>({\n\t\t\tsome: (result) => result.map(some),\n\t\t\tnone: () => ok(none)\n\t\t});\n\t}\n\n\t/**\n\t * Converts from `Result<Result<T, E>, E>` to `Result<T, E>`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<Option<number>> = some(some(6));\n\t * assert.equal(x.flatten(), some(6));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<Option<number>> = some(none);\n\t * assert.equal(x.flatten(), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<Option<number>> = none;\n\t * assert.equal(x.flatten(), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.flatten}\n\t */\n\tpublic flatten<InnerOption extends AnyOption, Exists extends boolean>(this: Option<InnerOption, Exists>): If<Exists, InnerOption, None> {\n\t\treturn this.match({ some: (inner) => inner, none: returnThis });\n\t}\n\n\t/**\n\t * Returns a `Promise` object with the awaited value (if `Some`).\n\t *\n\t * @example\n\t * ```typescript\n\t * let x = some(Promise.resolve(3));\n\t * assert.equal(await x.intoPromise(), some(3));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic intoPromise(): Promise<Option<Awaited<T>, Exists>> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.match({\n\t\t\tsome: async (value) => some(await value), // NOSONAR\n\t\t\tnone: () => Promise.resolve(none)\n\t\t});\n\t}\n\n\t/**\n\t * Checks whether or not `other` equals with self.\n\t * @param other The other option to compare.\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#tymethod.eq}\n\t */\n\tpublic eq<OtherValue extends T, OtherExists extends boolean>(other: Option<OtherValue, OtherExists>): this is Option<OtherValue, OtherExists> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isSome() === other.isSome() && this[ValueProperty] === other[ValueProperty];\n\t}\n\n\t/**\n\t * Checks whether or not `other` doesn't equal with self.\n\t * @param other The other option to compare.\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#method.ne}\n\t */\n\tpublic ne(other: Option<T, boolean>): boolean {\n\t\treturn !this.eq(other);\n\t}\n\n\t/**\n\t * Runs `ok` function if self is `Ok`, otherwise runs `err` function.\n\t * @param branches The branches to match.\n\t *\n\t * @example\n\t * ```typescript\n\t * const option = some(4).match({\n\t *   some: (v) => v,\n\t *   none: () => 0\n\t * });\n\t * assert.equal(option, 4);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const option = none.match({\n\t *   some: (v) => v,\n\t *   none: () => 0\n\t * });\n\t * assert.equal(option, 0);\n\t * ```\n\t */\n\tpublic match<SomeValue, NoneValue>(branches: {\n\t\tsome(this: Some<T>, value: T): SomeValue;\n\t\tnone(this: None): NoneValue;\n\t}): If<Exists, SomeValue, NoneValue> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isSome() ? branches.some.call(this, this[ValueProperty]) : branches.none.call(this);\n\t}\n\n\t/**\n\t * Returns an iterator over the possibly contained value.\n\t *\n\t * The iterator yields one value if the result is `Some`, otherwise none.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = some(7);\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Logs 7\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = none;\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link IOption.iter}\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.iter}\n\t */\n\tpublic [Symbol.iterator](): Generator<T> {\n\t\treturn this.iter();\n\t}\n\n\tpublic get [Symbol.toStringTag](): If<Exists, 'Some', 'None'> {\n\t\treturn this.match({ some: () => 'Some', none: () => 'None' });\n\t}\n\n\tpublic static readonly none = new Option<any, false>(null, false);\n\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static some<T = undefined>(this: void, value?: T): Some<T>;\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static some<T>(this: void, value: T): Some<T> {\n\t\treturn new Option<T, true>(value, true);\n\t}\n\n\t/**\n\t * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object. This override\n\t * exists to interoperate with other versions of this class, such as the one coming from another version of this\n\t * library or from a different build.\n\t *\n\t * @param instance The instance to check.\n\t * @returns Whether or not the instance is a `Option`.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Option } from '@sapphire/result';\n\t * const { some } = require('@sapphire/result');\n\t *\n\t * some(2) instanceof Option; // true\n\t * ```\n\t */\n\tpublic static [Symbol.hasInstance](instance: unknown): boolean {\n\t\treturn typeof instance === 'object' && instance !== null && ValueProperty in instance && ExistsProperty in instance;\n\t}\n\n\t/**\n\t * @deprecated Use {@link Option.isOption} instead.\n\t *\n\t * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object.\n\t *\n\t * @param instance The instance to check.\n\t * @returns true if the instance is a `Option` or a `Option`-like object, false otherwise.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Option } from '@sapphire/result';\n\t * const { some } = require('@sapphire/result');\n\t *\n\t * Option.isOption(some(2)); // true\n\t * ```\n\t */\n\tpublic static is(instance: unknown): instance is AnyOption {\n\t\treturn Option[Symbol.hasInstance](instance);\n\t}\n\n\t/**\n\t * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object.\n\t *\n\t * @param instance The instance to check.\n\t * @returns true if the instance is a `Option` or a `Option`-like object, false otherwise.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Option } from '@sapphire/result';\n\t * const { some } = require('@sapphire/result');\n\t *\n\t * Option.isOption(some(2)); // true\n\t * ```\n\t */\n\tpublic static isOption(instance: unknown): instance is AnyOption {\n\t\treturn Option[Symbol.hasInstance](instance);\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a callback.\n\t *\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static from<T>(this: void, op: OptionResolvable<T> | (() => OptionResolvable<T>)): Option<T> {\n\t\ttry {\n\t\t\treturn resolve(isFunction(op) ? op() : op);\n\t\t} catch {\n\t\t\treturn none;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a promise or async callback.\n\t *\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static async fromAsync<T>(this: void, op: Awaitable<OptionResolvable<T>> | (() => Awaitable<OptionResolvable<T>>)): Promise<Option<T>> {\n\t\ttry {\n\t\t\treturn resolve(await (isFunction(op) ? op() : op));\n\t\t} catch {\n\t\t\treturn none;\n\t\t}\n\t}\n\n\t/**\n\t * Creates an {@link Ok} that is the combination of all collected {@link Ok} values as an array, or the first\n\t * {@link Err} encountered.\n\t *\n\t * @param results An array of {@link Result}s.\n\t * @returns A new {@link Result}.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static all<const Entries extends readonly AnyOption[]>(this: void, results: Entries): Option<UnwrapSomeArray<Entries>> {\n\t\tconst values: unknown[] = [];\n\t\tfor (const result of results) {\n\t\t\tif (result.isNone()) return result;\n\n\t\t\tvalues.push(result[ValueProperty]);\n\t\t}\n\n\t\treturn some(values as UnwrapSomeArray<Entries>);\n\t}\n\n\t/**\n\t * Returns the first encountered {@link Some}, or a {@link None} if none was found.\n\t *\n\t * @param options An array of {@link Option}s.\n\t * @returns A new {@link Option}.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static any<const Entries extends readonly AnyOption[]>(this: void, results: Entries): Option<UnwrapSome<Entries[number]>> {\n\t\tfor (const result of results) {\n\t\t\tif (result.isSome()) return result;\n\t\t}\n\n\t\treturn none;\n\t}\n}\n\nexport namespace Option {\n\texport type Some<T> = Option<T, true>;\n\texport type None<T = any> = Option<T, false>;\n\texport type Any = Option<any>;\n\texport type Resolvable<T, Exists extends boolean = boolean> = T | null | undefined | Option<T, Exists>;\n\texport type UnwrapSome<T extends AnyOption> = T extends Some<infer S> ? S : never;\n\texport type UnwrapSomeArray<T extends readonly AnyOption[] | []> = {\n\t\t-readonly [P in keyof T]: UnwrapSome<T[P]>;\n\t};\n}\n\nexport const { some, none } = Option;\n\nfunction resolve<T>(value: Option.Resolvable<T>): Option<T> {\n\tif (value === null || value === undefined) return none;\n\tif (Option.isOption(value)) return value;\n\treturn some(value);\n}\n\nexport type OptionResolvable<T, Exists extends boolean = boolean> = Option.Resolvable<T, Exists>;\n\nexport type Some<T> = Option.Some<T>;\nexport type None<T = any> = Option.None<T>;\nexport type AnyOption = Option.Any;\n\nexport type UnwrapSome<T extends AnyOption> = Option.UnwrapSome<T>;\nexport type UnwrapSomeArray<T extends readonly AnyOption[] | []> = Option.UnwrapSomeArray<T>;\n","import { Option, Result } from '@sapphire/result';\nimport type { Parameter } from './lexer/streams/ParameterStream';\nimport type { ParserResult } from './parser/ParserResult';\n\nexport class ArgumentStream {\n\tpublic readonly results: ParserResult;\n\tpublic state: ArgumentStream.State;\n\n\tpublic constructor(results: ParserResult) {\n\t\tthis.results = results;\n\t\tthis.state = { used: new Set(), position: 0 };\n\t}\n\n\t/**\n\t * Whether or not all ordered parameters were used.\n\t */\n\tpublic get finished() {\n\t\treturn this.used === this.length;\n\t}\n\n\t/**\n\t * The amount of ordered parameters.\n\t */\n\tpublic get length() {\n\t\treturn this.results.ordered.length;\n\t}\n\n\t/**\n\t * The remaining amount of ordered parameters.\n\t */\n\tpublic get remaining() {\n\t\treturn this.length - this.used;\n\t}\n\n\t/**\n\t * The amount of ordered parameters that have been used.\n\t */\n\tpublic get used() {\n\t\treturn this.state.used.size;\n\t}\n\n\t/**\n\t * Retrieves the value of the next unused ordered token.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(args.single());\n\t * // Ok { value: '1' }\n\t *\n\t * console.log(args.single());\n\t * // Ok { value: '2' }\n\t *\n\t * console.log(args.single());\n\t * // Ok { value: '3' }\n\t *\n\t * console.log(args.single());\n\t * // None\n\t * ```\n\t *\n\t * @returns The value, if any.\n\t */\n\tpublic single(): Option<string> {\n\t\tif (this.finished) return Option.none;\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tthis.state.used.add(this.state.position);\n\t\treturn Option.some(this.results.ordered[this.state.position++].value);\n\t}\n\n\t/**\n\t * Retrieves the value of the next unused ordered token, but only if it could be transformed.\n\t *\n\t * @note This does not support asynchronous results, refer to {@link singleMapAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * const parse = (value) => {\n\t *   const number = Number(value);\n\t *   return Number.isNaN(number) ? Option.none : Option.some(number);\n\t * };\n\t *\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(args.singleMap(parse));\n\t * // Some { value: 1 }\n\t *\n\t * console.log(args.singleMap(parse));\n\t * // Some { value: 2 }\n\t *\n\t * console.log(args.singleMap(parse));\n\t * // Some { value: 3 }\n\t *\n\t * console.log(args.singleMap(parse));\n\t * // None\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.\n\t * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.\n\t * @returns The mapped value, if any.\n\t */\n\tpublic singleMap<T>(predicate: (value: string) => Option<T>, useAnyways = false): Option<T> {\n\t\tif (this.finished) return Option.none;\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tconst result = predicate(this.results.ordered[this.state.position].value);\n\t\tif (result.isSome() || useAnyways) {\n\t\t\tthis.state.used.add(this.state.position);\n\t\t\t++this.state.position;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Retrieves the value of the next unused ordered token, but only if it could be transformed.\n\t *\n\t * @note This is an asynchronous variant of {@link singleMap}.\n\t *\n\t * @typeparam T The output type.\n\t * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.\n\t * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.\n\t * @returns The mapped value, if any.\n\t */\n\tpublic async singleMapAsync<T>(predicate: (value: string) => Promise<Option<T>>, useAnyways = false): Promise<Option<T>> {\n\t\tif (this.finished) return Option.none;\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tconst result = await predicate(this.results.ordered[this.state.position].value);\n\t\tif (result.isSome() || useAnyways) {\n\t\t\tthis.state.used.add(this.state.position);\n\t\t\t++this.state.position;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Finds and retrieves the next unused parameter and transforms it.\n\t *\n\t * @note This is a variant of {@link findMap} that returns the errors on failure.\n\t * @note This does not support asynchronous results, refer to {@link singleParseAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * const parse = (value) => {\n\t *   const number = Number(value);\n\t *   return Number.isNaN(number)\n\t *     ? Result.err(`Could not parse ${value} to a number`)\n\t *     : Result.ok(number);\n\t * };\n\t *\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(args.singleParse(parse));\n\t * // Ok { value: 1 }\n\t *\n\t * console.log(args.singleParse(parse));\n\t * // Ok { value: 2 }\n\t *\n\t * console.log(args.singleParse(parse));\n\t * // Ok { value: 3 }\n\t *\n\t * console.log(args.singleParse(parse));\n\t * // Err { error: null }\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @typeparam E The error type.\n\t * @param predicate The predicate that determines the parameter's transformed value, or nothing if failed.\n\t * @param useAnyways Whether to consider the parameter used even if the transformation failed. Defaults to `false`.\n\t * @returns The transformed value, if any.\n\t */\n\tpublic singleParse<T, E>(predicate: (value: string) => Result<T, E>, useAnyways = false): Result<T, E | null> {\n\t\tif (this.finished) return Result.err(null);\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tconst result = predicate(this.results.ordered[this.state.position].value);\n\t\tif (result.isOk() || useAnyways) {\n\t\t\tthis.state.used.add(this.state.position);\n\t\t\t++this.state.position;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Retrieves the value of the next unused ordered token, but only if it could be transformed.\n\t *\n\t * @note This is an asynchronous variant of {@link singleParse}.\n\t *\n\t * @typeparam T The output type.\n\t * @typeparam E The error type.\n\t * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.\n\t * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.\n\t * @returns The mapped value, if any.\n\t */\n\tpublic async singleParseAsync<T, E>(predicate: (value: string) => Promise<Result<T, E>>, useAnyways = false): Promise<Result<T, E | null>> {\n\t\tif (this.finished) return Result.err(null);\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tconst result = await predicate(this.results.ordered[this.state.position].value);\n\t\tif (result.isOk() || useAnyways) {\n\t\t\tthis.state.used.add(this.state.position);\n\t\t\t++this.state.position;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns the value of the first element in the array within `Option.some` where `predicate` returns `true`, and\n\t * `Option.none` otherwise.\n\t *\n\t * @note This does not support asynchronous results, refer to {@link findAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Suppose args are from 'ba aa cc'.\n\t *\n\t * console.log(args.find((value) => value.startsWith('a')));\n\t * // Some { value: 'aa' }\n\t * ```\n\t *\n\t * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it\n\t * finds one where `predicate` returns `true`. If such an element is found, find immediately returns a `Option.some`\n\t * with that element value. Otherwise, find returns `Option.none`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic find(predicate: (value: string) => boolean, from = this.state.position): Option<string> {\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tif (predicate(parameter)) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn Option.some(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn Option.none;\n\t}\n\n\t/**\n\t * Returns the value of the first element in the array within `Option.some` where `predicate` returns `true`, and\n\t * `Option.none` otherwise.\n\t *\n\t * @note This is an asynchronous variant of {@link find}.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Suppose args are from 'ba aa cc'.\n\t *\n\t * console.log(args.find((value) => value.startsWith('a')));\n\t * // Some { value: 'aa' }\n\t * ```\n\t *\n\t * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it\n\t * finds one where `predicate` returns `true`. If such an element is found, find immediately returns a `Option.some`\n\t * with that element value. Otherwise, find returns `Option.none`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic async findAsync(predicate: (value: string) => Promise<boolean>, from = this.state.position): Promise<Option<string>> {\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tif (await predicate(parameter)) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn Option.some(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn Option.none;\n\t}\n\n\t/**\n\t * Returns the value of the first element in the array within `Option.some` where `predicate` returns `Some`, and\n\t * `Option.none` otherwise.\n\t *\n\t * @note This does not support asynchronous results, refer to {@link findMapAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Suppose args are from 'ba aa cc'.\n\t *\n\t * console.log(args.find((value) => value.startsWith('a')));\n\t * // Some { value: 'aa' }\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it\n\t * finds one where `predicate` returns `Some`. If such an element is found, find immediately returns the returned\n\t * value. Otherwise, find returns `Option.none`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic findMap<T>(predicate: (value: string) => Option<T>, from = this.state.position): Option<T> {\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = predicate(parameter);\n\t\t\tif (result.isSome()) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn Option.none;\n\t}\n\n\t/**\n\t * Returns the value of the first element in the array within `Option.some` where `predicate` returns `Some`, and\n\t * `Option.none` otherwise.\n\t *\n\t * @note This is an asynchronous variant of {@link findMap}.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Suppose args are from 'ba aa cc'.\n\t *\n\t * console.log(args.find((value) => value.startsWith('a')));\n\t * // Some { value: 'aa' }\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it\n\t * finds one where `predicate` returns `Some`. If such an element is found, find immediately returns the returned\n\t * value. Otherwise, find returns `Option.none`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic async findMapAsync<T>(predicate: (value: string) => Promise<Option<T>>, from = this.state.position): Promise<Option<T>> {\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = await predicate(parameter);\n\t\t\tif (result.isSome()) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn Option.none;\n\t}\n\n\t/**\n\t * Finds and retrieves the first unused parameter that could be transformed.\n\t *\n\t * @note This is a variant of {@link findMap} that returns the errors on failure.\n\t * @note This does not support asynchronous results, refer to {@link findParseAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * const parse = (value) => {\n\t *   const number = Number(value);\n\t *   return Number.isNaN(number)\n\t *     ? Result.err(`Could not parse ${value} to a number`)\n\t *     : Result.ok(number);\n\t * };\n\t *\n\t * // Suppose args are from 'ba 1 cc'.\n\t *\n\t * console.log(args.findParse(parse));\n\t * // Ok { value: 1 }\n\t *\n\t * console.log(args.findParse(parse));\n\t * // Err {\n\t * //   error: [\n\t * //     'Could not parse ba to a number',\n\t * //     'Could not parse cc to a number'\n\t * //   ]\n\t * // }\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @typeparam E The error type.\n\t * @param predicate `findParse` calls `predicate` once for each unused ordered parameter, in ascending order, until\n\t * it finds one where `predicate` returns `Ok`. If such an element is found, `findParse` immediately returns the\n\t * returned value. Otherwise, `findParse` returns `Result.Err` with all the returned errors.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic findParse<T, E>(predicate: (value: string) => Result<T, E>, from = this.state.position): Result<T, E[]> {\n\t\tconst errors: E[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = predicate(parameter);\n\t\t\tif (result.isOk()) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn result as Result.Ok<T>;\n\t\t\t}\n\n\t\t\terrors.push(result.unwrapErr());\n\t\t}\n\n\t\treturn Result.err(errors);\n\t}\n\n\t/**\n\t * Finds and retrieves the first unused parameter that could be transformed.\n\t *\n\t * @note This is a variant of {@link findMapAsync} that returns the errors on failure.\n\t * @note This is an asynchronous variant of {@link findParse}.\n\t *\n\t * @typeparam T The output type.\n\t * @typeparam E The error type.\n\t * @param predicate `findParse` calls `predicate` once for each unused ordered parameter, in ascending order, until\n\t * it finds one where `predicate` returns `Ok`. If such an element is found, `findParse` immediately returns the\n\t * returned value. Otherwise, `findParse` returns `Result.Err` with all the returned errors.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic async findParseAsync<T, E>(predicate: (value: string) => Promise<Result<T, E>>, from = this.state.position): Promise<Result<T, E[]>> {\n\t\tconst errors: E[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = await predicate(parameter);\n\t\t\tif (result.isOk()) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn result as Result.Ok<T>;\n\t\t\t}\n\n\t\t\terrors.push(result.unwrapErr());\n\t\t}\n\n\t\treturn Result.err(errors);\n\t}\n\n\t/**\n\t * Retrieves multiple unused parameters.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(join(args.many().unwrap()));\n\t * // '1 2 3'\n\t * ```\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(join(args.many(2).unwrap()));\n\t * // '1 2'\n\t * ```\n\t *\n\t * @param limit The maximum amount of parameters to retrieve, defaults to `Infinity`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The unused parameters within the range.\n\t */\n\tpublic many(limit = Infinity, from = this.state.position): Option<Parameter[]> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: Parameter[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\t// If the current parameter was already used, skip:\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\t// Mark current parameter as used, and push it to the resulting array:\n\t\t\tthis.state.used.add(i);\n\t\t\tparameters.push(this.results.ordered[i]);\n\n\t\t\t// If the parameters reached the limit, break the loop:\n\t\t\tif (parameters.length >= limit) break;\n\t\t}\n\n\t\treturn parameters.length ? Option.some(parameters) : Option.none;\n\t}\n\n\tpublic filter(predicate: (value: string) => boolean, from = this.state.position): Option<string[]> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: string[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tif (predicate(parameter)) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\tparameters.push(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn Option.some(parameters);\n\t}\n\n\tpublic async filterAsync(predicate: (value: string) => Promise<boolean>, from = this.state.position): Promise<Option<string[]>> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: string[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tif (await predicate(parameter)) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\tparameters.push(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn Option.some(parameters);\n\t}\n\n\tpublic filterMap<T>(predicate: (value: string) => Option<T>, from = this.state.position): Option<T[]> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: T[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = predicate(parameter);\n\t\t\tresult.inspect((value) => {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\tparameters.push(value);\n\t\t\t});\n\t\t}\n\n\t\treturn Option.some(parameters);\n\t}\n\n\tpublic async filterMapAsync<T>(predicate: (value: string) => Promise<Option<T>>, from = this.state.position): Promise<Option<T[]>> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: T[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = await predicate(parameter);\n\t\t\tresult.inspect((value) => {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\tparameters.push(value);\n\t\t\t});\n\t\t}\n\n\t\treturn Option.some(parameters);\n\t}\n\n\t/**\n\t * Checks whether any of the flags were given.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '--f --g':\n\t *\n\t * console.log(args.flag('f'));\n\t * // true\n\t *\n\t * console.log(args.flag('g', 'h'));\n\t * // true\n\t *\n\t * console.log(args.flag('h'));\n\t * // false\n\t * ```\n\t *\n\t * @param keys The names of the flags to check.\n\t * @returns Whether or not any of the flags were given.\n\t */\n\tpublic flag(...keys: readonly string[]): boolean {\n\t\treturn keys.some((key) => this.results.flags.has(key));\n\t}\n\n\t/**\n\t * Gets the last value of any option. When there are multiple names, the last value of the last found name is given.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '--a=1 --b=2 --c=3'.\n\t * console.log(args.option('a'));\n\t * // Some { value: '1' }\n\t *\n\t * console.log(args.option('b', 'c'));\n\t * // Some { value: '3' }\n\t *\n\t * console.log(args.option('d'));\n\t * // None {}\n\t * ```\n\t *\n\t * @param keys The names of the options to check.\n\t * @returns The last value of the option, if any.\n\t */\n\tpublic option(...keys: readonly string[]): Option<string> {\n\t\treturn this.options(...keys).map((values) => values.at(-1)!);\n\t}\n\n\t/**\n\t * Gets all values from all options.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '--a=1 --a=1 --b=2 --c=3'.\n\t * console.log(args.option('a'));\n\t * // Some { value: ['1', '1'] }\n\t *\n\t * console.log(args.option('b', 'c'));\n\t * // Some { value: ['2', '3'] }\n\t *\n\t * console.log(args.option('d'));\n\t * // None {}\n\t * ```\n\t *\n\t * @param keys The names of the options to check.\n\t * @returns The values from all the options concatenated, if any.\n\t */\n\tpublic options(...keys: readonly string[]): Option<readonly string[]> {\n\t\tconst entries: string[] = [];\n\t\tfor (const key of keys) {\n\t\t\tconst values = this.results.options.get(key);\n\t\t\tif (values) entries.push(...values);\n\t\t}\n\n\t\treturn entries.length ? Option.some(entries) : Option.none;\n\t}\n\n\tpublic save(): ArgumentStream.State {\n\t\treturn {\n\t\t\tused: new Set(this.state.used),\n\t\t\tposition: this.state.position\n\t\t};\n\t}\n\n\tpublic restore(state: ArgumentStream.State) {\n\t\tthis.state = state;\n\t}\n\n\tpublic reset() {\n\t\tthis.restore({ used: new Set(), position: 0 });\n\t}\n}\n\nexport namespace ArgumentStream {\n\texport interface State {\n\t\tused: Set<number>;\n\t\tposition: number;\n\t}\n}\n","export abstract class BaseParameter {\n\tpublic readonly separators: readonly string[];\n\n\tpublic constructor(separators: readonly string[]) {\n\t\tthis.separators = separators;\n\t}\n\n\tpublic get leading(): string {\n\t\treturn this.separators.join('');\n\t}\n\n\tpublic abstract get raw(): string;\n}\n","import type { QuotedToken } from '../raw/TokenStream';\nimport { BaseParameter } from './BaseParameter';\n\nexport class QuotedParameter extends BaseParameter {\n\tpublic readonly value: string;\n\tpublic readonly open: string;\n\tpublic readonly close: string;\n\n\tpublic constructor(separators: readonly string[], part: Omit<QuotedToken, 'type'>) {\n\t\tsuper(separators);\n\t\tthis.value = part.value;\n\t\tthis.open = part.open;\n\t\tthis.close = part.close;\n\t}\n\n\tpublic get raw() {\n\t\treturn `${this.open}${this.value}${this.close}`;\n\t}\n}\n","import type { WordToken } from '../raw/TokenStream';\nimport { BaseParameter } from './BaseParameter';\n\nexport class WordParameter extends BaseParameter {\n\tpublic readonly value: string;\n\n\tpublic constructor(separators: readonly string[], part: Omit<WordToken, 'type'>) {\n\t\tsuper(separators);\n\t\tthis.value = part.value;\n\t}\n\n\tpublic get raw() {\n\t\treturn this.value;\n\t}\n}\n","import type { Lexer } from '../../Lexer';\n\nexport class TokenStream implements Iterable<Token> {\n\tprivate readonly input: string;\n\tprivate readonly quotes: readonly [string, string][];\n\tprivate readonly separator: string;\n\tprivate position = 0;\n\n\tpublic constructor(lexer: Lexer, input: string) {\n\t\tthis.quotes = lexer.quotes;\n\t\tthis.separator = lexer.separator;\n\t\tthis.input = input;\n\t}\n\n\tpublic get finished() {\n\t\treturn this.position >= this.input.length;\n\t}\n\n\tpublic *[Symbol.iterator](): Iterator<Token> {\n\t\twhile (!this.finished) {\n\t\t\tyield this.getPossibleSeparator() ?? this.getPossibleQuotedArgument() ?? this.getParameter();\n\t\t}\n\t}\n\n\tprivate getPossibleSeparator(): SeparatorToken | null {\n\t\tif (this.input.startsWith(this.separator, this.position)) {\n\t\t\tthis.position += this.separator.length;\n\t\t\treturn { type: TokenType.Separator, value: this.separator };\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate getPossibleQuotedArgument(): QuotedToken | null {\n\t\tfor (const [open, close] of this.quotes) {\n\t\t\tif (!this.input.startsWith(open, this.position)) continue;\n\n\t\t\tconst end = this.input.indexOf(close, this.position + open.length);\n\t\t\tif (end === -1) continue;\n\n\t\t\tconst value = this.input.slice(this.position + open.length, end);\n\t\t\tthis.position = end + close.length;\n\n\t\t\treturn { type: TokenType.Quoted, value, open, close };\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate getParameter(): WordToken {\n\t\tconst index = this.input.indexOf(this.separator, this.position);\n\t\tconst value = index === -1 ? this.input.slice(this.position) : this.input.slice(this.position, index);\n\t\tthis.position += value.length;\n\t\treturn { type: TokenType.Parameter, value };\n\t}\n}\n\nexport enum TokenType {\n\tParameter,\n\tQuoted,\n\tSeparator\n}\n\nexport type Token = WordToken | QuotedToken | SeparatorToken;\n\nexport interface WordToken {\n\treadonly type: TokenType.Parameter;\n\treadonly value: string;\n}\n\nexport interface QuotedToken {\n\treadonly type: TokenType.Quoted;\n\treadonly value: string;\n\treadonly open: string;\n\treadonly close: string;\n}\n\nexport interface SeparatorToken {\n\treadonly type: TokenType.Separator;\n\treadonly value: string;\n}\n","import { QuotedParameter } from './parameters/QuotedParameter';\nimport { WordParameter } from './parameters/WordParameter';\nimport { TokenType, type Token } from './raw/TokenStream';\n\nexport class ParameterStream {\n\tprivate readonly stream: Iterable<Token>;\n\tprivate separators: string[] = [];\n\n\tpublic constructor(stream: Iterable<Token>) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic *[Symbol.iterator](): Iterator<Parameter, string[]> {\n\t\tfor (const part of this.stream) {\n\t\t\tif (part.type === TokenType.Separator) {\n\t\t\t\tthis.separators.push(part.value);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tyield part.type === TokenType.Quoted ? new QuotedParameter(this.separators, part) : new WordParameter(this.separators, part);\n\t\t\tthis.separators = [];\n\t\t}\n\n\t\treturn this.separators;\n\t}\n}\n\nexport type Parameter = QuotedParameter | WordParameter;\n","import { ParameterStream } from './streams/ParameterStream';\nimport { TokenStream } from './streams/raw/TokenStream';\n\nexport class Lexer {\n\tpublic readonly quotes: readonly [open: string, close: string][];\n\tpublic readonly separator: string;\n\n\tpublic constructor(options: Lexer.Options = {}) {\n\t\tthis.quotes = options.quotes ?? [];\n\t\tthis.separator = options.separator ?? ' ';\n\t}\n\n\tpublic run(input: string) {\n\t\treturn new ParameterStream(this.raw(input));\n\t}\n\n\tpublic raw(input: string) {\n\t\treturn new TokenStream(this, input);\n\t}\n}\n\nexport namespace Lexer {\n\texport interface Options {\n\t\tseparator?: string;\n\t\tquotes?: readonly [open: string, close: string][];\n\t}\n}\n","import type { Parameter } from '../lexer/streams/ParameterStream';\nimport type { Parser } from './Parser';\nimport type { IUnorderedStrategy } from './strategies/IUnorderedStrategy';\n\nexport class ParserResult {\n\tpublic readonly ordered: Parameter[] = [];\n\tpublic readonly flags = new Set<string>();\n\tpublic readonly options = new Map<string, string[]>();\n\tprivate readonly strategy: IUnorderedStrategy;\n\n\tpublic constructor(parser: Parser) {\n\t\tthis.strategy = parser.strategy;\n\t}\n\n\tpublic parse(parameters: Iterable<Parameter>) {\n\t\tfor (const parameter of parameters) {\n\t\t\tthis.parsePossibleFlag(parameter) || this.parsePossibleOptions(parameter) || this.parseOrdered(parameter);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprivate parsePossibleFlag(parameter: Parameter): boolean {\n\t\treturn this.strategy\n\t\t\t.matchFlag(parameter.value)\n\t\t\t.inspect((value) => this.flags.add(value))\n\t\t\t.isSome();\n\t}\n\n\tprivate parsePossibleOptions(parameter: Parameter): boolean {\n\t\treturn this.strategy\n\t\t\t.matchOption(parameter.value)\n\t\t\t.inspect(([key, value]) => {\n\t\t\t\tconst existing = this.options.get(key);\n\t\t\t\tif (existing) existing.push(value);\n\t\t\t\telse this.options.set(key, [value]);\n\t\t\t})\n\t\t\t.isSome();\n\t}\n\n\tprivate parseOrdered(parameter: Parameter): boolean {\n\t\tthis.ordered.push(parameter);\n\t\treturn true;\n\t}\n}\n","import { Option } from '@sapphire/result';\nimport type { IUnorderedStrategy } from './IUnorderedStrategy';\n\nexport class EmptyStrategy implements IUnorderedStrategy {\n\tpublic matchFlag(): Option<string> {\n\t\treturn Option.none;\n\t}\n\n\tpublic matchOption(): Option<readonly [key: string, value: string]> {\n\t\treturn Option.none;\n\t}\n}\n","import type { Parameter } from '../lexer/streams/ParameterStream';\nimport type { IUnorderedStrategy } from './strategies/IUnorderedStrategy';\nimport { ParserResult } from './ParserResult';\nimport { EmptyStrategy } from './strategies/EmptyStrategy';\n\nexport class Parser {\n\tpublic strategy: IUnorderedStrategy;\n\n\tpublic constructor(strategy?: IUnorderedStrategy) {\n\t\tthis.strategy = strategy ?? new EmptyStrategy();\n\t}\n\n\tpublic setUnorderedStrategy(strategy: IUnorderedStrategy) {\n\t\tthis.strategy = strategy;\n\t\treturn this;\n\t}\n\n\tpublic run(input: Iterable<Parameter>): ParserResult {\n\t\treturn new ParserResult(this).parse(input);\n\t}\n}\n","import { Option } from '@sapphire/result';\nimport type { IUnorderedStrategy } from './IUnorderedStrategy';\n\nexport class PrefixedStrategy implements IUnorderedStrategy {\n\tpublic readonly prefixes: readonly string[];\n\tpublic readonly separators: readonly string[];\n\n\tpublic constructor(prefixes: readonly string[], separators: readonly string[]) {\n\t\tthis.prefixes = prefixes;\n\t\tthis.separators = separators;\n\t}\n\n\tpublic matchFlag(input: string): Option<string> {\n\t\tconst prefix = this.prefixes.find((x) => input.startsWith(x));\n\n\t\t// If the prefix is missing, return None:\n\t\tif (!prefix) return Option.none;\n\n\t\t// If the separator is present, return None:\n\t\tif (this.separators.some((x) => input.includes(x, prefix.length))) return Option.none;\n\n\t\treturn Option.some(input.slice(prefix.length));\n\t}\n\n\tpublic matchOption(input: string): Option<readonly [key: string, value: string]> {\n\t\tconst prefix = this.prefixes.find((x) => input.startsWith(x));\n\n\t\t// If the prefix is missing, return None:\n\t\tif (!prefix) return Option.none;\n\n\t\tfor (const separator of this.separators) {\n\t\t\tconst index = input.indexOf(separator, prefix.length + 1);\n\n\t\t\t// If the separator is missing, skip:\n\t\t\tif (index === -1) continue;\n\n\t\t\t// If the separator is present, but has no value, return None:\n\t\t\tif (index + separator.length === input.length) return Option.none;\n\n\t\t\tconst key = input.slice(prefix.length, index);\n\t\t\tconst value = input.slice(index + separator.length);\n\t\t\treturn Option.some([key, value] as const);\n\t\t}\n\n\t\treturn Option.none;\n\t}\n}\n","import type { Parameter } from '../lexer/streams/ParameterStream';\n\n/**\n * Joins the parameters by their `leading` value, using the `value` property.\n * @seealso {@link joinRaw} for the version using `raw` instead of `value`.\n * @param parameters The parameters to join.\n * @returns The result of joining the parameters.\n */\nexport function join(parameters: readonly Parameter[]) {\n\tif (parameters.length === 0) return '';\n\tif (parameters.length === 1) return parameters[0].value;\n\n\tlet output = parameters[0].value;\n\tfor (let i = 1; i < parameters.length; i++) {\n\t\tconst parameter = parameters[i];\n\t\toutput += parameter.leading + parameter.value;\n\t}\n\n\treturn output;\n}\n\n/**\n * Joins the parameters by their `leading` value, using the `raw` property.\n * @seealso {@link join} for the version using `value` instead of `raw`.\n * @param parameters The parameters to join.\n * @returns The result of joining the parameters.\n */\nexport function joinRaw(parameters: readonly Parameter[]) {\n\tif (parameters.length === 0) return '';\n\tif (parameters.length === 1) return parameters[0].raw;\n\n\tlet output = parameters[0].raw;\n\tfor (let i = 1; i < parameters.length; i++) {\n\t\tconst parameter = parameters[i];\n\t\toutput += parameter.leading + parameter.raw;\n\t}\n\n\treturn output;\n}\n"]}