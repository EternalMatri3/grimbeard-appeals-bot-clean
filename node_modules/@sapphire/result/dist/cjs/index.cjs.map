{"version":3,"sources":["../../src/lib/common/utils.ts","../../src/lib/OptionError.ts","../../src/lib/ResultError.ts","../../src/lib/Result.ts","../../src/lib/Option.ts"],"names":["value","ValueProperty","_a","_b","resolve"],"mappings":"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","file":"index.cjs","sourcesContent":["export type Awaitable<T> = PromiseLike<T> | T;\n\nexport type If<Value extends boolean, TrueResult, FalseResult> = Value extends true\n\t? TrueResult\n\t: Value extends false\n\t\t? FalseResult\n\t\t: TrueResult | FalseResult;\n\nexport function isFunction<A extends readonly any[], R>(cb: (...args: A) => R): true;\nexport function isFunction(input: any): input is (...args: readonly any[]) => any;\nexport function isFunction(input: any) {\n\treturn typeof input === 'function';\n}\n\nexport function isPromise<T>(input: PromiseLike<T>): true;\nexport function isPromise(input: any): input is PromiseLike<any>;\nexport function isPromise(input: any) {\n\treturn typeof input === 'object' && input !== null && typeof input.then === 'function';\n}\n\nexport function returnThis<U>(this: U): U {\n\treturn this;\n}\n","export class OptionError extends Error {\n\tpublic override get name(): string {\n\t\treturn this.constructor.name;\n\t}\n}\n","export class ResultError<E> extends Error {\n\tpublic readonly value: E;\n\n\tpublic constructor(message: string, value: E) {\n\t\tsuper(message);\n\t\tthis.value = value;\n\t}\n\n\tpublic override get name(): string {\n\t\treturn this.constructor.name;\n\t}\n}\n","import { isFunction, returnThis, type Awaitable, type If } from './common/utils';\nimport { none, some, type None, type Option, type Some } from './Option';\nimport { ResultError } from './ResultError';\n\nconst ValueProperty = Symbol.for('@sapphire/result:Result.value');\nconst SuccessProperty = Symbol.for('@sapphire/result:Result.success');\n\n/**\n * A type used to express computations that can fail, it can be used for returning and propagating errors. This is a\n * type union with the variants `Ok(T)`, representing success and containing a value, and `Err(E)`, representing error\n * and containing an error value.\n *\n * @typeparam T The result's type.\n * @typeparam E The error's type.\n *\n * @see {@link https://doc.rust-lang.org/std/result/index.html}\n */\nexport class Result<T, E, const Success extends boolean = boolean> {\n\t/**\n\t * Branded value to ensure `Success` is typed correctly.\n\t * @internal\n\t */\n\tdeclare protected __STATUS__: Success;\n\n\tprivate readonly [ValueProperty]: If<Success, T, E>;\n\tprivate readonly [SuccessProperty]: Success;\n\n\tprivate constructor(value: If<Success, T, E>, success: Success) {\n\t\tthis[ValueProperty] = value;\n\t\tthis[SuccessProperty] = success;\n\t}\n\n\t/**\n\t * Returns `true` if the result is `Ok`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(-3);\n\t * assert.equal(x.isOk(), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Some error message');\n\t * assert.equal(x.isOk(), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_ok}\n\t */\n\tpublic isOk(): this is Ok<T, E> {\n\t\treturn this[SuccessProperty];\n\t}\n\n\t/**\n\t * Returns `true` if the result is `Ok` and the value inside of it matches a predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.isOkAnd((value) => value > 1), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = ok(0);\n\t * assert.equal(x.isOkAnd((value) => value > 1), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Some error message');\n\t * assert.equal(x.isOkAnd((value) => value > 1), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_ok_and}\n\t */\n\tpublic isOkAnd<R extends T>(cb: (value: T) => value is R): this is Ok<R, E>;\n\tpublic isOkAnd<R extends boolean>(cb: (value: T) => R): this is Ok<T, E> & R;\n\tpublic isOkAnd<R extends boolean>(cb: (value: T) => R): this is Ok<T, E> & R {\n\t\treturn this.isOk() && cb(this[ValueProperty]);\n\t}\n\n\t/**\n\t * Returns `true` if the result is `Err`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(-3);\n\t * assert.equal(x.isErr(), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Some error message');\n\t * assert.equal(x.isErr(), true);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_err}\n\t */\n\tpublic isErr(): this is Err<E, T> {\n\t\treturn !this[SuccessProperty];\n\t}\n\n\t/**\n\t * Returns `true` if the result is `Err` and the value inside of it matches a predicate.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.isErrAnd((error) => error instanceof TypeError), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err(new Error('Some error message'));\n\t * assert.equal(x.isErrAnd((error) => error instanceof TypeError), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err(new TypeError('Some error message'));\n\t * assert.equal(x.isErrAnd((error) => error instanceof TypeError), true);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_err_and}\n\t */\n\tpublic isErrAnd<R extends E>(cb: (error: E) => error is R): this is Err<R, T>;\n\tpublic isErrAnd<R extends boolean>(cb: (error: E) => R): this is Err<E, T> & R;\n\tpublic isErrAnd<R extends boolean>(cb: (error: E) => R): this is Err<E, T> & R {\n\t\treturn this.isErr() && cb(this[ValueProperty]);\n\t}\n\n\t/**\n\t * Converts from `Result<T, E>` to `Option<T>`.\n\t *\n\t * Converts itself into an `Option<T>`, and discarding the error, if any.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.ok(), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.ok(), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.ok}\n\t */\n\tpublic ok(): If<Success, Some<T>, None> {\n\t\treturn this.match({ ok: (value) => some(value), err: () => none });\n\t}\n\n\t/**\n\t * Converts from `Result<T, E>` to `Option<E>`.\n\t *\n\t * Converts itself into an `Option<E>`, and discarding the successful value, if any.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.err(), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.err(), 'Some error message');\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.err}\n\t */\n\tpublic err(): If<Success, None, Some<E>> {\n\t\treturn this.match({ ok: () => none, err: (error) => some(error) });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a contained `Ok` value, leaving an `Err` value\n\t * untouched.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.map((value) => value * 2), ok(4));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.map((value) => value * 2), err('Some error message'));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map}\n\t */\n\tpublic map<OutputValue>(cb: (value: If<Success, T, never>) => OutputValue): Result<OutputValue, E, Success> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.match({ ok: (value) => ok(cb(value)), err: returnThis });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Ok` value, leaving an `Err` value\n\t * untouched.\n\t *\n\t * Unlike {@link map}, this method does not wrap the returned value inside `Ok`, but instead, it returns the\n\t * returned value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.mapInto((value) => ok(value * value)), ok(4));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(0);\n\t * assert.equal(\n\t *   x.mapInto((value) => (value === 0 ? err('zero is not divisible') : ok(1 / value))),\n\t *   err('zero is not divisible')\n\t * );\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.mapInto((value) => ok(4)), err('Some error message'));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic mapInto<OutputResult extends AnyResult>(cb: (value: If<Success, T, never>) => OutputResult): If<Success, OutputResult, Err<E>> {\n\t\treturn this.match({ ok: (value) => cb(value), err: returnThis });\n\t}\n\n\t/**\n\t * Returns the provided default (if `Err`), or applies a function to the contained value (if `Ok`),\n\t *\n\t * Arguments passed to `mapOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use `mapOrElse`, which is lazily evaluated.\n\t * @param defaultValue The default value to use.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok('hello');\n\t * assert.equal(x.mapOr(42, (value) => value.length), 5);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Some error message');\n\t * assert.equal(x.mapOr(42, (value) => value.length), 42);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or}\n\t */\n\tpublic mapOr<MappedOutputValue, DefaultOutputValue>(\n\t\tdefaultValue: DefaultOutputValue,\n\t\tcb: (value: If<Success, T, never>) => MappedOutputValue\n\t): If<Success, MappedOutputValue, DefaultOutputValue> {\n\t\treturn this.match({ ok: (value) => cb(value), err: () => defaultValue });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `U` by applying fallback function default to a contained `Err` value, or function `cb`\n\t * to a contained `Ok` value.\n\t *\n\t * This function can be used to unpack a successful result while handling an error.\n\t * @param op The predicate that is run on `Err`.\n\t * @param cb The predicate that is run on `Ok`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<string, string> = ok('hello');\n\t * assert.equal(x.mapOrElse((error) => error.length, (value) => value.length), 5);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<string, string> = err('Some error message');\n\t * assert.equal(x.mapOrElse((error) => error.length, (value) => value.length), 18);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or_else}\n\t */\n\tpublic mapOrElse<OutputValue, OutputError>(\n\t\top: (error: If<Success, never, E>) => OutputError,\n\t\tcb: (value: If<Success, T, never>) => OutputValue\n\t): If<Success, OutputValue, OutputError> {\n\t\treturn this.match({ ok: (value) => cb(value), err: (error) => op(error) });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Err` value, leaving an `Ok` value\n\t * untouched.\n\t *\n\t * This function can be used to pass through a successful result while handling an error.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = ok(2);\n\t * assert.equal(x.mapErr((error) => error.message), ok(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = err(new Error('Some error message'));\n\t * assert.equal(x.mapErr((error) => error.message), err('Some error message'));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err}\n\t */\n\tpublic mapErr<OutputError>(cb: (error: If<Success, never, E>) => OutputError): Result<T, OutputError, Success> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.match({ ok: returnThis, err: (error) => err(cb(error)) });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Err` value, leaving an `Ok` value\n\t * untouched.\n\t *\n\t * This function can be used to pass through a successful result while handling an error.\n\t *\n\t * Unlike {@link mapErr}, this method does not wrap the returned value inside `Err`, but instead, it returns the\n\t * returned value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = ok(2);\n\t * assert.equal(x.mapErrInto((error) => err(error.message)), ok(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = err(new Error('Some error message'));\n\t * assert.equal(x.mapErrInto((error) => err(error.message)), err('Some error message'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = err(new Error('Some error message'));\n\t * assert.equal(x.mapErrInto((error) => ok(4)), ok(4));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic mapErrInto<OutputResult extends AnyResult>(cb: (error: If<Success, never, E>) => OutputResult): If<Success, Ok<T>, OutputResult> {\n\t\treturn this.match({ ok: returnThis, err: (error) => cb(error) });\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained value (if `Ok`).\n\t * @param cb The predicate.\n\t * @seealso {@link inspectAsync} for the awaitable version.\n\t *\n\t * @example\n\t * ```typescript\n\t * ok(2).inspect(console.log);\n\t * // Logs: 2\n\t * ```\n\t * @example\n\t * ```typescript\n\t * err('Some error message').inspect(console.log);\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.inspect}\n\t */\n\tpublic inspect(cb: (value: T) => unknown): this {\n\t\tif (this.isOk()) cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained value (if `Ok`) and awaits it.\n\t * @param cb The predicate.\n\t * @seealso {@link inspect} for the sync version.\n\t *\n\t * @example\n\t * ```typescript\n\t * await ok(2).inspectAsync(console.log);\n\t * // Logs: 2\n\t * ```\n\t * @example\n\t * ```typescript\n\t * await err('Some error message').inspectAsync(console.log);\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic async inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this> {\n\t\tif (this.isOk()) await cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained error (if `Err`).\n\t * @param cb The predicate.\n\t * @seealso {@link inspectErrAsync} for the awaitable version.\n\t *\n\t * @example\n\t * ```typescript\n\t * ok(2).inspectErr(console.log);\n\t * // Doesn't log\n\t * ```\n\t * @example\n\t * ```typescript\n\t * err('Some error message').inspectErr(console.log);\n\t * // Logs: Some error message\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.inspect_err}\n\t */\n\tpublic inspectErr(cb: (error: E) => unknown): this {\n\t\tif (this.isErr()) cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained error (if `Err`) and awaits it.\n\t * @param cb The predicate.\n\t * @seealso {@link inspectErr} for the sync version.\n\t *\n\t * @example\n\t * ```typescript\n\t * await ok(2).inspectErrAsync(console.log);\n\t * // Doesn't log\n\t * ```\n\t * @example\n\t * ```typescript\n\t * await err('Some error message').inspectErrAsync(console.log);\n\t * // Logs: Some error message\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic async inspectErrAsync(cb: (error: E) => Awaitable<unknown>): Promise<this> {\n\t\tif (this.isErr()) await cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an iterator over the possibly contained value.\n\t *\n\t * The iterator yields one value if the result is `Ok`, otherwise none.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(7);\n\t * for (const value of x.iter()) {\n\t *   console.log(value);\n\t * }\n\t * // Logs 7\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Nothing!');\n\t * for (const value of x.iter()) {\n\t *   console.log(value);\n\t * }\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.iter}\n\t */\n\tpublic *iter(): Generator<T> {\n\t\tif (this.isOk()) yield this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value.\n\t *\n\t * If the value is an `Err`, it throws a {@link ResultError} with the given message and the content of the `Err`.\n\t * @param message The message for the error.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.expect('Whoops!'), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.throws(() => x.expect('Whoops!'), {\n\t *   name: 'ResultError',\n\t *   message: 'Whoops',\n\t *   value: 'Emergency failure'\n\t * });\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.expect}\n\t */\n\tpublic expect(message: string): If<Success, T, never> {\n\t\tif (this.isErr()) throw new ResultError(message, this[ValueProperty]);\n\t\treturn this[ValueProperty] as If<Success, T, never>;\n\t}\n\n\t/**\n\t * Returns the contained `Err` value.\n\t *\n\t * If the value is an `Ok`, it throws a {@link ResultError} with the given message and the content of the `Ok`.\n\t * @param message The message for the error.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.throws(() => x.expectErr('Whoops!'), {\n\t *   name: 'ResultError',\n\t *   message: 'Whoops',\n\t *   value: 2\n\t * });\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.equal(x.expectErr('Whoops!'), 'Emergency failure');\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.expect_err}\n\t */\n\tpublic expectErr(message: string): If<Success, never, E> {\n\t\tif (this.isOk()) throw new ResultError(message, this[ValueProperty]);\n\t\treturn this[ValueProperty] as If<Success, never, E>;\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value.\n\t *\n\t * If the value is an `Err`, it throws a {@link ResultError} with the message, and the content of the `Err`.\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapOrElse}\n\t * @seealso {@link unwrapErr}\n\t * @seealso {@link unwrapRaw}\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.unwrap(), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.throws(() => x.unwrap(), {\n\t *   name: 'ResultError',\n\t *   message: 'Unwrap failed',\n\t *   value: 'Emergency failure'\n\t * });\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap}\n\t */\n\tpublic unwrap(): If<Success, T, never> {\n\t\tif (this.isErr()) throw new ResultError('Unwrap failed', this[ValueProperty]);\n\t\treturn this[ValueProperty] as If<Success, T, never>;\n\t}\n\n\t/**\n\t * Returns the contained `Err` value.\n\t *\n\t * If the value is an `Ok`, it throws a {@link ResultError} with the message, and the content of the `Ok`.\n\t * @seealso {@link unwrap}\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapOrElse}\n\t * @seealso {@link unwrapRaw}\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.throws(() => x.unwrapErr(), {\n\t *   name: 'ResultError',\n\t *   message: 'Unwrap failed',\n\t *   value: 2\n\t * });\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.equal(x.unwrapErr(), 'Emergency failure');\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_err}\n\t */\n\tpublic unwrapErr(): If<Success, never, E> {\n\t\tif (this.isOk()) throw new ResultError('Unwrap failed', this[ValueProperty]);\n\t\treturn this[ValueProperty] as If<Success, never, E>;\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value or the provided default.\n\t *\n\t * Arguments passed to `unwrapOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use {@link unwrapOrElse}, which is lazily evaluated.\n\t * @seealso {@link unwrap}\n\t * @seealso {@link unwrapOrElse}\n\t * @seealso {@link unwrapErr}\n\t * @seealso {@link unwrapRaw}\n\t *\n\t * @param defaultValue The default value.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(9);\n\t * assert.equal(x.unwrapOr(2), 9);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Error');\n\t * assert.equal(x.unwrapOr(2), 2);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or}\n\t */\n\tpublic unwrapOr<OutputValue>(defaultValue: OutputValue): If<Success, T, OutputValue> {\n\t\treturn this.match({ ok: (value) => value, err: () => defaultValue });\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value or computes it from a closure.\n\t * @seealso {@link unwrap}\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapErr}\n\t * @seealso {@link unwrapRaw}\n\t *\n\t * @param op The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const count = (x: string) => x.length;\n\t *\n\t * assert.equal(ok(2).unwrapOrElse(count), 2);\n\t * assert.equal(err('hello').unwrapOrElse(count), 5);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or_else}\n\t */\n\tpublic unwrapOrElse<OutputValue>(op: (error: E) => OutputValue): If<Success, T, OutputValue> {\n\t\treturn this.match({ ok: (value) => value, err: (error) => op(error) });\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value.\n\t *\n\t * If the value is an `Err`, it throws the contained error.\n\t * @seealso {@link unwrap}\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapOrElse}\n\t * @seealso {@link unwrapErr}\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.unwrapRaw(), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.throws(() => x.unwrapRaw(), {\n\t *   name: 'Error',\n\t *   message: 'Unwrap failed',\n\t *   value: 'Emergency failure'\n\t * });\n\t * ```\n\t */\n\tpublic unwrapRaw(): If<Success, T, never> {\n\t\t// eslint-disable-next-line @typescript-eslint/no-throw-literal\n\t\tif (this.isErr()) throw this[ValueProperty];\n\t\t// @ts-expect-error Complex types\n\t\treturn this[ValueProperty] as T;\n\t}\n\n\t/**\n\t * Returns `result` if the result is `Ok`, otherwise returns the `Err` value of itself.\n\t * @param result The result to check.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * const y: Result<string, string> = err('Late error');\n\t * assert.equal(x.and(y), err('Late error'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Early error');\n\t * const y: Result<string, string> = err('Late error');\n\t * assert.equal(x.and(y), err('Early error'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * const y: Result<string, string> = ok('Hello');\n\t * assert.equal(x.and(y), ok('Hello'));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and}\n\t */\n\tpublic and<OutputResult extends AnyResult>(result: OutputResult): If<Success, OutputResult, Err<E>> {\n\t\treturn this.match({ ok: () => result, err: returnThis });\n\t}\n\n\t/**\n\t * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.\n\t *\n\t * This function can be used for control flow based on `Result` values.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * function fractionOf4(value: number) {\n\t *   return value === 0 ? err('overflowed') : ok(4 / value);\n\t * }\n\t *\n\t * assert.equal(ok(2).andThen(fractionOf4), ok(4));\n\t * assert.equal(ok(0).andThen(fractionOf4), err('overflowed'));\n\t * assert.equal(err('not a number').andThen(fractionOf4), err('not a number'));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then}\n\t */\n\tpublic andThen<OutputResult extends AnyResult>(cb: (value: T) => OutputResult): If<Success, OutputResult, Err<E>> {\n\t\treturn this.match({ ok: (value) => cb(value), err: returnThis });\n\t}\n\n\t/**\n\t * Return `result` if the result is `Err`, otherwise returns the `Ok` value of self.\n\t *\n\t * Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended\n\t * to use {@link orElse}, which is lazily evaluated.\n\t * @param result The result to check.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * const y: Result<number, string> = err('Late error');\n\t * assert.equal(x.or(y), ok(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Early error');\n\t * const y: Result<number, string> = ok(2);\n\t * assert.equal(x.or(y), ok(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Early error');\n\t * const y: Result<number, string> = err('Late error');\n\t * assert.equal(x.or(y), err('Late error'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * const y: Result<number, string> = ok(100);\n\t * assert.equal(x.or(y), ok(2));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.or}\n\t */\n\tpublic or<OutputResult extends AnyResult>(result: OutputResult): If<Success, Ok<T>, OutputResult> {\n\t\treturn this.match({ ok: returnThis, err: () => result });\n\t}\n\n\t/**\n\t * Calls `cb` if the result is `Err`, otherwise returns the `Ok` value of self.\n\t *\n\t * This function can be used for control flow based on result values.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const square = (x: number): Result<number, string> => ok(x * x);\n\t * const wrapErr = (x: number): Result<number, string> => err(x);\n\t *\n\t * assert.equal(ok(2).orElse(square).orElse(square), ok(2));\n\t * assert.equal(ok(2).orElse(wrapErr).orElse(square), ok(2));\n\t * assert.equal(err(3).orElse(square).orElse(wrapErr), ok(9));\n\t * assert.equal(err(3).orElse(wrapErr).orElse(wrapErr), err(3));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.or_else}\n\t */\n\tpublic orElse<OutputResult extends AnyResult>(cb: (error: E) => OutputResult): If<Success, Ok<T>, OutputResult> {\n\t\treturn this.match({ ok: returnThis, err: (error) => cb(error) });\n\t}\n\n\t/**\n\t * Returns `true` if the result is an `Ok` and the given value strict equals it.\n\t * @param value The value to compare.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.contains(2), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(3);\n\t * assert.equal(x.contains(2), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.contains(2), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.contains}\n\t */\n\tpublic contains<const Value extends T>(this: Ok<T>, value: Value): this is Ok<Value>;\n\tpublic contains(this: Err<E>, value: T): false;\n\tpublic contains(value: T): boolean {\n\t\treturn this.isOkAnd((inner) => inner === value);\n\t}\n\n\t/**\n\t * Returns `true` if the result is an `Err` and the given error strict equals it.\n\t * @param error The error to compare.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.containsErr('Some error message'), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.containsErr('Some error message'), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some other error message');\n\t * assert.equal(x.containsErr('Some error message'), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.contains_err}\n\t */\n\tpublic containsErr(this: Ok<T>, error: E): false;\n\tpublic containsErr<const Value extends E>(this: Err<E>, error: Value): this is Err<Value>;\n\tpublic containsErr(error: E): boolean {\n\t\treturn this.isErrAnd((inner) => inner === error);\n\t}\n\n\t/**\n\t * Transposes a `Result` of an `Option` into an `Option` of a `Result`.\n\t *\n\t * `ok(none)` will be mapped to `none`. `ok(some(v))` and `err(e)` will be mapped to `some(ok(v))` and `some(err(e))`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<Option<number>, Error> = ok(some(5));\n\t * const y: Option<Result<number, Error>> = some(ok(5));\n\t * assert.equal(x.transpose(), y);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.transpose}\n\t */\n\tpublic transpose<InnerValue>(this: Result<Option<InnerValue>, E, Success>): If<Success, Option<Ok<InnerValue>>, Some<Err<E>>> {\n\t\treturn this.match({\n\t\t\tok: (value) => value.map((value) => ok(value)),\n\t\t\terr() {\n\t\t\t\treturn some(this);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Converts from `Result<Result<T, E>, E>` to `Result<T, E>`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<Result<string, number>, number> = ok(ok('Hello'));\n\t * assert.equal(x.flatten(), ok('Hello'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<Result<string, number>, number> = ok(err(6));\n\t * assert.equal(x.flatten(), err(6));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<Result<string, number>, number> = err(6);\n\t * assert.equal(x.flatten(), err(6));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.flatten}\n\t */\n\tpublic flatten<InnerResult extends AnyResult>(this: Result<InnerResult, E, Success>): If<Success, InnerResult, Err<E>> {\n\t\treturn this.match({ ok: (value) => value, err: returnThis });\n\t}\n\n\t/**\n\t * Returns the `Ok` value if self is `Ok`, and the `Err` value if self is `Err`.\n\t *\n\t * @example\n\t * ```typescript\n\t * let x: Result<number, number> = ok(3);\n\t * assert.equal(x.intoOkOrErr(), 3);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * let x: Result<number, number> = err(4);\n\t * assert.equal(x.intoOkOrErr(), 4);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.into_ok_or_err}\n\t */\n\tpublic intoOkOrErr(): If<Success, T, E> {\n\t\treturn this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns a `Promise` object with the awaited value (if `Ok`) or the awaited error (if `Err`).\n\t *\n\t * @example\n\t * ```typescript\n\t * let x = ok(Promise.resolve(3));\n\t * assert.equal(await x.intoPromise(), ok(3));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic intoPromise(): Promise<If<Success, Ok<Awaited<T>>, Err<Awaited<E>>>> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.match<Ok<Awaited<T>>, Err<Awaited<E>>>({\n\t\t\t// @ts-expect-error Complex types\n\t\t\tok: async (value) => ok(await value), // NOSONAR\n\t\t\t// @ts-expect-error Complex types\n\t\t\terr: async (error) => err(await error) // NOSONAR\n\t\t});\n\t}\n\n\t/**\n\t * Checks whether or not `other` equals with self.\n\t * @param other The other result to compare.\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#tymethod.eq}\n\t */\n\tpublic eq<OtherValue extends T, OtherError extends E, OtherSuccess extends boolean>(\n\t\tother: Result<OtherValue, OtherError, OtherSuccess>\n\t): this is Result<OtherValue, OtherError, OtherSuccess> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isOk() === other.isOk() && this[ValueProperty] === other[ValueProperty];\n\t}\n\n\t/**\n\t * Checks whether or not `other` doesn't equal with self.\n\t * @param other The other result to compare.\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#method.ne}\n\t */\n\tpublic ne(other: Result<T, E>): boolean {\n\t\treturn !this.eq(other);\n\t}\n\n\t/**\n\t * Runs `ok` function if self is `Ok`, otherwise runs `err` function.\n\t * @param branches The branches to match.\n\t *\n\t * @example\n\t * ```typescript\n\t * const result = ok(4).match({\n\t *   ok: (v) => v,\n\t *   err: () => 0\n\t * });\n\t * assert.equal(result, 4);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const result = err('Hello').match({\n\t *   ok: (v) => v,\n\t *   err: () => 0\n\t * });\n\t * assert.equal(result, 0);\n\t * ```\n\t */\n\tpublic match<OkValue, ErrValue>(branches: {\n\t\tok(this: Ok<T>, value: If<Success, T, never>): OkValue;\n\t\terr(this: Err<E>, error: If<Success, never, E>): ErrValue;\n\t}): If<Success, OkValue, ErrValue> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isOk() ? branches.ok.call(this, this[ValueProperty]) : branches.err.call(this, this[ValueProperty] as E);\n\t}\n\n\t/**\n\t * Returns an iterator over the possibly contained value.\n\t *\n\t * The iterator yields one value if the result is `Ok`, otherwise none.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(7);\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Logs 7\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Nothing!');\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link IResult.iter}\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.iter}\n\t */\n\tpublic [Symbol.iterator](): Generator<T> {\n\t\treturn this.iter();\n\t}\n\n\tpublic get [Symbol.toStringTag](): If<Success, 'Ok', 'Err'> {\n\t\treturn this.match({ ok: () => 'Ok', err: () => 'Err' });\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static ok<T = undefined, E = any>(this: void, value?: T): Ok<T, E>;\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static ok<T, E = any>(this: void, value: T): Ok<T, E> {\n\t\treturn new Result<T, E, true>(value, true);\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static err<E = undefined, T = any>(this: void, value?: E): Err<E, T>;\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static err<E, T = any>(this: void, value: E): Err<E, T> {\n\t\treturn new Result<T, E, false>(value, false);\n\t}\n\n\t/**\n\t * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object. This override\n\t * exists to interoperate with other versions of this class, such as the one coming from another version of this\n\t * library or from a different build.\n\t *\n\t * @param instance The instance to check.\n\t * @returns Whether or not the instance is a `Result`.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Result } from '@sapphire/result';\n\t * const { ok } = require('@sapphire/result');\n\t *\n\t * ok(2) instanceof Result; // true\n\t * ```\n\t */\n\tpublic static [Symbol.hasInstance](instance: unknown): boolean {\n\t\treturn typeof instance === 'object' && instance !== null && ValueProperty in instance && SuccessProperty in instance;\n\t}\n\n\t/**\n\t * @deprecated Use {@link Result.isResult} instead.\n\t *\n\t * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object.\n\t *\n\t * @param instance The instance to check.\n\t * @returns true if the instance is a `Result` or a `Result`-like object, false otherwise.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Result } from '@sapphire/result';\n\t * const { ok } = require('@sapphire/result');\n\t *\n\t * Result.isResult(ok(2)); // true\n\t * ```\n\t */\n\tpublic static is(instance: unknown): instance is AnyResult {\n\t\treturn Result[Symbol.hasInstance](instance);\n\t}\n\n\t/**\n\t * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object.\n\t *\n\t * @param instance The instance to check.\n\t * @returns true if the instance is a `Result` or a `Result`-like object, false otherwise.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Result } from '@sapphire/result';\n\t * const { ok } = require('@sapphire/result');\n\t *\n\t * Result.isResult(ok(2)); // true\n\t * ```\n\t */\n\tpublic static isResult(instance: unknown): instance is AnyResult {\n\t\treturn Result[Symbol.hasInstance](instance);\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a callback.\n\t *\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static from<T, E = unknown>(this: void, op: ResultResolvable<T, E> | (() => ResultResolvable<T, E>)): Result<T, E> {\n\t\ttry {\n\t\t\treturn resolve(isFunction(op) ? op() : op);\n\t\t} catch (error) {\n\t\t\treturn err(error as E);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a promise or async callback.\n\t *\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\tpublic static async fromAsync<T, E = unknown>(\n\t\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\t\tthis: void,\n\t\top: Awaitable<ResultResolvable<T, E>> | (() => Awaitable<ResultResolvable<T, E>>)\n\t): Promise<Result<T, E>> {\n\t\ttry {\n\t\t\treturn resolve(await (isFunction(op) ? op() : op));\n\t\t} catch (error) {\n\t\t\treturn err(error as E);\n\t\t}\n\t}\n\n\t/**\n\t * Creates an {@link Ok} that is the combination of all collected {@link Ok} values as an array, or the first\n\t * {@link Err} encountered.\n\t *\n\t * @param results An array of {@link Result}s.\n\t * @returns A new {@link Result}.\n\t */\n\tpublic static all<const Entries extends readonly AnyResult[]>(\n\t\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\t\tthis: void,\n\t\tresults: Entries\n\t): Result<UnwrapOkArray<Entries>, UnwrapErrArray<Entries>[number]> {\n\t\tconst values: unknown[] = [];\n\t\tfor (const result of results) {\n\t\t\tif (result.isErr()) return result;\n\n\t\t\tvalues.push(result[ValueProperty]);\n\t\t}\n\n\t\treturn ok(values as UnwrapOkArray<Entries>);\n\t}\n\n\t/**\n\t * Returns the first encountered {@link Ok}, or an {@link Err} that is the combination of all collected error values.\n\t *\n\t * @param results An array of {@link Result}s.\n\t * @returns A new {@link Result}.\n\t */\n\tpublic static any<const Entries extends readonly AnyResult[]>(\n\t\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\t\tthis: void,\n\t\tresults: Entries\n\t): Result<UnwrapOk<Entries[number]>, UnwrapErrArray<Entries>> {\n\t\tconst errors: unknown[] = [];\n\t\tfor (const result of results) {\n\t\t\tif (result.isOk()) return result;\n\n\t\t\terrors.push(result[ValueProperty]);\n\t\t}\n\n\t\treturn err(errors as UnwrapErrArray<Entries>);\n\t}\n}\n\nexport namespace Result {\n\texport type Ok<T, E = any> = Result<T, E, true>;\n\texport type Err<E, T = any> = Result<T, E, false>;\n\texport type Any = Result<any, any>;\n\texport type Resolvable<T, E = any, Success extends boolean = boolean> = T | Result<T, E, Success>;\n\texport type UnwrapOk<T extends AnyResult> = T extends Ok<infer S> ? S : never;\n\texport type UnwrapErr<T extends AnyResult> = T extends Err<infer S> ? S : never;\n\n\texport type UnwrapOkArray<T extends readonly AnyResult[] | []> = {\n\t\t-readonly [P in keyof T]: UnwrapOk<T[P]>;\n\t};\n\texport type UnwrapErrArray<T extends readonly AnyResult[] | []> = {\n\t\t-readonly [P in keyof T]: UnwrapErr<T[P]>;\n\t};\n}\n\nexport const { ok, err } = Result;\n\nfunction resolve<T, E>(value: Result.Resolvable<T, E>): Result<T, E> {\n\treturn Result.isResult(value) ? value : ok(value);\n}\n\nexport type ResultResolvable<T, E = any, Success extends boolean = boolean> = Result.Resolvable<T, E, Success>;\n\nexport type Ok<T, E = any> = Result.Ok<T, E>;\nexport type Err<E, T = any> = Result.Err<E, T>;\nexport type AnyResult = Result.Any;\n\nexport type UnwrapOk<T extends AnyResult> = Result.UnwrapOk<T>;\nexport type UnwrapErr<T extends AnyResult> = Result.UnwrapErr<T>;\n\nexport type UnwrapOkArray<T extends readonly AnyResult[] | []> = Result.UnwrapOkArray<T>;\nexport type UnwrapErrArray<T extends readonly AnyResult[] | []> = Result.UnwrapErrArray<T>;\n","import { isFunction, returnThis, type Awaitable, type If } from './common/utils';\nimport { OptionError } from './OptionError';\nimport { err, ok, Result, type Err, type Ok } from './Result';\n\nconst ValueProperty = Symbol.for('@sapphire/result:Option.value');\nconst ExistsProperty = Symbol.for('@sapphire/result:Option.exists');\n\nexport class Option<T, Exists extends boolean = boolean> {\n\t/**\n\t * Branded value to ensure `Success` is typed correctly.\n\t * @internal\n\t */\n\tdeclare protected __STATUS__: Exists;\n\n\tprivate readonly [ValueProperty]: If<Exists, T, null>;\n\tprivate readonly [ExistsProperty]: Exists;\n\n\tprivate constructor(value: If<Exists, T, null>, exists: Exists) {\n\t\tthis[ValueProperty] = value;\n\t\tthis[ExistsProperty] = exists;\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `Some` value.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.isSome(), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.isSome(), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some}\n\t */\n\tpublic isSome(): this is Some<T> {\n\t\treturn this[ExistsProperty];\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `Some` and the value inside of it matches a predicate.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.isSomeAnd((x) => x > 1), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(0);\n\t * assert.equal(x.isSomeAnd((x) => x > 1), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.isSomeAnd((x) => x > 1), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some_and}\n\t */\n\tpublic isSomeAnd<R extends T>(cb: (value: T) => value is R): this is Some<R>;\n\tpublic isSomeAnd<R extends boolean>(cb: (value: T) => R): this is Some<R> & R;\n\tpublic isSomeAnd<R extends boolean>(cb: (value: T) => R): this is Some<R> & R {\n\t\treturn this.isSome() && cb(this[ValueProperty]);\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `None` value.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.isNone(), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.isNone(), true);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_none}\n\t */\n\tpublic isNone(): this is None {\n\t\treturn !this[ExistsProperty];\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `None` value or the value inside of it matches a predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.isNoneOr((x) => x > 1), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(0);\n\t * assert.equal(x.isNoneOr((x) => x > 1), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.isNoneOr((x) => x > 1), true);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_none_or}\n\t */\n\tpublic isNoneOr<R extends T>(cb: (value: T) => value is R): this is None | Some<R>;\n\tpublic isNoneOr<R extends boolean>(cb: (value: T) => R): If<Exists, R, true>;\n\tpublic isNoneOr<R extends boolean>(cb: (value: T) => R): If<Exists, R, true> {\n\t\treturn this.match({ some: (value) => cb(value), none: () => true });\n\t}\n\n\t/**\n\t * Returns the contained `Some` value.\n\t * @param message The message for the error.\n\t * If the value is an `Err`, it throws an {@link OptionError} with the given message.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some(2);\n\t * assert.equal(x.expect('Whoops!'), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.throws(() => x.expect('Whoops!'), {\n\t *   name: 'OptionError',\n\t *   message: 'Whoops'\n\t * });\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.expect}\n\t */\n\tpublic expect(message: string): If<Exists, T, never> {\n\t\tif (this.isNone()) throw new OptionError(message);\n\t\t// @ts-expect-error Complex types\n\t\treturn this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns the contained `Some` value.\n\t *\n\t * If the value is an `Err`, it throws an {@link OptionError} with the message.\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapOrElse}\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some(2);\n\t * assert.equal(x.unwrap(), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.throws(() => x.unwrap(), {\n\t *   name: 'OptionError',\n\t *   message: 'Unwrap failed'\n\t * });\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap}\n\t */\n\tpublic unwrap(): If<Exists, T, never> {\n\t\tif (this.isNone()) throw new OptionError('Unwrap failed');\n\t\t// @ts-expect-error Complex types\n\t\treturn this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns the contained `Some` value or a provided default.\n\t *\n\t * Arguments passed to `unwrapOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use {@link unwrapOrElse}, which is lazily evaluated.\n\t *\n\t * @example\n\t * ```typescript\n\t * assert.equal(some(2).unwrapOr(0), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * assert.equal(none.unwrapOr(0), 0);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or}\n\t */\n\tpublic unwrapOr<OutputValue>(defaultValue: OutputValue): If<Exists, T, OutputValue> {\n\t\treturn this.match({ some: (value) => value, none: () => defaultValue });\n\t}\n\n\t/**\n\t * Returns the contained Some value or computes it from a closure.\n\t *\n\t * @example\n\t * ```typescript\n\t * assert.equal(some(2).unwrapOrElse(() => 0), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * assert.equal(none.unwrapOrElse(() => 0), 0);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else}\n\t */\n\tpublic unwrapOrElse<OutputValue>(cb: () => OutputValue): If<Exists, T, OutputValue> {\n\t\treturn this.match({ some: (value) => value, none: cb });\n\t}\n\n\t/**\n\t * Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const maybeSomeString = some('Hello, world!');\n\t * const maybeSomeLength = maybeSomeString.map((value) => value.length);\n\t *\n\t * assert.equal(maybeSomeLength, some(13));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map}\n\t */\n\tpublic map<U>(cb: (value: T) => U): If<Exists, Some<U>, None> {\n\t\treturn this.match({ some: (value) => some(cb(value)), none: returnThis });\n\t}\n\n\t/**\n\t * Maps a `Some<T>` to the returned `Option<U>` by applying a function to a contained value, leaving `None`\n\t * untouched.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const input: Option<string> = some('Hello, world!');\n\t * const result = input.mapInto((value) => some(value.length));\n\t *\n\t * assert.equal(result, some(13));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const input: Option<string> = none;\n\t * const result = input.mapInto((value) => some(value.length));\n\t *\n\t * assert.equal(result, none);\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic mapInto<OutputOption extends AnyOption>(cb: (value: T) => OutputOption): If<Exists, OutputOption, None> {\n\t\treturn this.match({ some: (value) => cb(value), none: returnThis });\n\t}\n\n\t/**\n\t * Returns the provided default result (if none), or applies a function to the contained value (if any).\n\t *\n\t * Arguments passed to `mapOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use {@link mapOrElse}, which is lazily evaluated.\n\t * @param defaultValue The default value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some('hello');\n\t * assert.equal(x.mapOr(42, (value) => value.length), 5);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.equal(x.mapOr(42, (value) => value.length), 42);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or}\n\t */\n\tpublic mapOr<MappedOutputValue, DefaultOutputValue>(\n\t\tdefaultValue: DefaultOutputValue,\n\t\tcb: (value: T) => MappedOutputValue\n\t): If<Exists, MappedOutputValue, DefaultOutputValue> {\n\t\treturn this.match({ some: (value) => cb(value), none: () => defaultValue });\n\t}\n\n\t/**\n\t * Computes a default function result (if none), or applies a different function to the contained value (if any).\n\t * @param defaultValue The default value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some('hello');\n\t * assert.equal(x.mapOrElse(() => 42, (value) => value.length), 5);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.equal(x.mapOrElse(() => 42, (value) => value.length), 42);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or_else}\n\t */\n\tpublic mapOrElse<OutputValue, OutputNone>(defaultValue: () => OutputNone, cb: (value: T) => OutputValue): If<Exists, OutputValue, OutputNone> {\n\t\treturn this.match({ some: (value) => cb(value), none: () => defaultValue() });\n\t}\n\n\t/**\n\t * Maps a `None` to the returned `Option<U>` by applying a function to a contained value, leaving `Some<T>`\n\t * untouched.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const input: Option<string> = some('Hello, world!');\n\t * const result = input.mapNoneInto(() => some(13));\n\t *\n\t * assert.equal(result, some('Hello, world!'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const input: Option<string> = none;\n\t * const result = input.mapNoneInto(() => some(13));\n\t *\n\t * assert.equal(result, some(13));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic mapNoneInto<OutputOption extends AnyOption>(cb: () => OutputOption): If<Exists, Some<T>, OutputOption> {\n\t\treturn this.match({ some: returnThis, none: cb });\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained value (if `Some`).\n\t * @param cb The predicate.\n\t * @seealso {@link inspectAsync} for the awaitable version.\n\t *\n\t * @example\n\t * ```typescript\n\t * some(2).inspect(console.log);\n\t * // Logs: 2\n\t * ```\n\t * @example\n\t * ```typescript\n\t * none.inspect(console.log);\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.inspect}\n\t */\n\tpublic inspect(cb: (value: T) => void): this {\n\t\tif (this.isSome()) cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained value (if `Some`).\n\t * @param cb The predicate.\n\t * @seealso {@link inspect} for the sync version.\n\t *\n\t * @example\n\t * ```typescript\n\t * await some(2).inspectAsync(console.log);\n\t * // Logs: 2\n\t * ```\n\t * @example\n\t * ```typescript\n\t * await none.inspectAsync(console.log);\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic async inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this> {\n\t\tif (this.isSome()) await cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to `Ok(v)` and `None` to `Err(err)`.\n\t *\n\t * Arguments passed to `okOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use {@link okOrElse}, which is lazily evaluated.\n\t * @param err The error to be used.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some('hello');\n\t * assert.equal(x.okOr(0), ok('hello'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.equal(x.okOr(0), err(0));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or}\n\t */\n\tpublic okOr<ErrorValue>(error: ErrorValue): If<Exists, Ok<T>, Err<ErrorValue>> {\n\t\treturn this.match({ some: (value) => ok(value), none: () => err(error) });\n\t}\n\n\t/**\n\t * Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to `Ok(v)` and `None` to `Err(err())`.\n\t * @param cb The error to be used.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some('hello');\n\t * assert.equal(x.okOrElse(() => 0), ok('hello'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.equal(x.okOrElse(() => 0), err(0));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or_else}\n\t */\n\tpublic okOrElse<ErrorValue>(cb: () => ErrorValue): If<Exists, Ok<T>, Err<ErrorValue>> {\n\t\treturn this.match({ some: (value) => ok(value), none: () => err(cb()) });\n\t}\n\n\t/**\n\t * Returns an iterator over the possibly contained value.\n\t *\n\t * The iterator yields one value if the result is `Some`, otherwise none.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = some(7);\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Logs 7\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = none;\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link Option.iter}\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.iter}\n\t */\n\tpublic *iter(): Generator<T> {\n\t\tif (this.isSome()) yield this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns `None` if the option is `None`, otherwise returns `option`.\n\t * @param option The option.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<string> = none;\n\t * assert.equal(x.and(y), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<string> = some('foo');\n\t * assert.equal(x.and(y), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<string> = some('foo');\n\t * assert.equal(x.and(y), some('foo'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<string> = none;\n\t * assert.equal(x.and(y), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.and}\n\t */\n\tpublic and<OutputOption extends AnyOption>(option: OutputOption): If<Exists, OutputOption, None> {\n\t\treturn this.match({ some: () => option, none: returnThis });\n\t}\n\n\t/**\n\t * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.\n\t *\n\t * This function can be used for control flow based on `Result` values.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * function fractionOf4(value: number) {\n\t *   return value === 0 ? none : some(4 / value);\n\t * }\n\t *\n\t * assert.equal(some(2).andThen(fractionOf4), some(4));\n\t * assert.equal(some(0).andThen(fractionOf4), none);\n\t * assert.equal(none.andThen(fractionOf4), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then}\n\t */\n\tpublic andThen<OutputOption extends AnyOption>(cb: (value: T) => OutputOption): If<Exists, OutputOption, None> {\n\t\treturn this.match({ some: (value) => cb(value), none: returnThis });\n\t}\n\n\t/**\n\t * Returns the option if it contains a value, otherwise returns `option`.\n\t * @param option The option.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<number> = none;\n\t * assert.equal(x.or(y), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<number> = some(100);\n\t * assert.equal(x.or(y), some(100));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<number> = some(100);\n\t * assert.equal(x.or(y), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<number> = none;\n\t * assert.equal(x.or(y), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.or}\n\t */\n\tpublic or<OutputOption extends AnyOption>(option: OutputOption): If<Exists, Some<T>, OutputOption> {\n\t\treturn this.match({ some: returnThis, none: () => option });\n\t}\n\n\t/**\n\t * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.\n\t *\n\t * This function can be used for control flow based on `Result` values.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const nobody = (): Option<string> => none;\n\t * const vikings = (): Option<string> => some('vikings');\n\t *\n\t * assert.equal(some('barbarians').orElse(vikings), some('barbarians'));\n\t * assert.equal(none.orElse(vikings), some('vikings'));\n\t * assert.equal(none.orElse(nobody), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.or_else}\n\t */\n\tpublic orElse<OutputOption extends AnyOption>(cb: () => OutputOption): If<Exists, Some<T>, OutputOption> {\n\t\treturn this.match({ some: returnThis, none: () => cb() });\n\t}\n\n\t/**\n\t * Returns `Some` if exactly one of self or `option` is `Some`, otherwise returns `None`.\n\t * @param option The option to compare.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<number> = none;\n\t * assert.equal(x.xor(y), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<number> = some(2);\n\t * assert.equal(x.xor(y), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<number> = some(2);\n\t * assert.equal(x.xor(y), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<number> = none;\n\t * assert.equal(x.xor(y), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.xor}\n\t */\n\tpublic xor<OtherValue, OtherExists extends boolean>(\n\t\toption: Option<OtherValue, OtherExists>\n\t): If<Exists, If<OtherExists, None, Some<T>>, Option<OtherValue, OtherExists>> {\n\t\treturn this.match<If<OtherExists, None, Some<T>>, Option<OtherValue, OtherExists>>({\n\t\t\tsome() {\n\t\t\t\treturn (option.isNone() ? this : none) as If<OtherExists, None, Some<T>>;\n\t\t\t},\n\t\t\tnone: () => option\n\t\t});\n\t}\n\n\t/**\n\t * Returns None if the option is None, otherwise calls `predicate` with the wrapped value and returns:\n\t *\n\t * - `Some(t)` if `predicate` returns `true` (where t is the wrapped value), and\n\t * - `None` if `predicate` returns `false`.\n\t * @param predicate The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * function isEven(value: number) {\n\t *   return n % 2 === 0;\n\t * }\n\t *\n\t * assert.equal(none.filter(isEven), none);\n\t * assert.equal(some(3).filter(isEven), none);\n\t * assert.equal(some(4).filter(isEven), some(4));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.filter}\n\t */\n\tpublic filter<R extends T>(predicate: (value: T) => value is R): Option<R>;\n\tpublic filter(predicate: (value: T) => boolean): Option<T>;\n\tpublic filter(predicate: (value: T) => boolean): Option<T> {\n\t\treturn this.isSomeAnd(predicate) ? this : none;\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `Some` value containing the given value.\n\t * @param value The value to compare.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.contains(2), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(3);\n\t * assert.equal(x.contains(2), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.contains(2), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.contains}\n\t */\n\tpublic contains<const Value extends T>(value: If<Exists, Value, unknown>): this is Some<Value> {\n\t\treturn this.isSomeAnd((inner) => inner === value);\n\t}\n\n\t/**\n\t * Zips self with another `Option`.\n\t *\n\t * If self is `Some(s)` and `other` is `Some(o)`, this method returns `Some([s, o])`. Otherwise, `None` is returned.\n\t * @param other The option to zip self with.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = some(1);\n\t * const y = some('hi');\n\t * const z = none;\n\t *\n\t * assert.equal(x.zip(y), some([1, 'hi']));\n\t * assert.equal(x.zip(z), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.zip}\n\t */\n\tpublic zip<OtherValue, OtherExists extends boolean>(\n\t\tother: Option<OtherValue, OtherExists>\n\t): Option<[T, OtherValue], If<Exists, OtherExists, false>> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isSome() && other.isSome() ? some([this[ValueProperty], other[ValueProperty]] as [T, OtherValue]) : none;\n\t}\n\n\t/**\n\t * Zips self and another `Option` with function `f`.\n\t *\n\t * If self is `Some(s)` and other is `Some(o)`, this method returns `Some(f(s, o))`. Otherwise, `None` is returned.\n\t * @param other The option to zip self with.\n\t * @param f The function that computes the returned value.\n\t *\n\t * @example\n\t * ```typescript\n\t * class Point {\n\t *   public readonly x: number;\n\t *   public readonly y: number;\n\t *\n\t *   public constructor(x: number, y: number) {\n\t *     this.x = x;\n\t *     this.y = y;\n\t *   }\n\t * }\n\t *\n\t * const x = some(17.5);\n\t * const y = some(42.7);\n\t *\n\t * assert.equal(x.zipWith(y, (s, o) => new Point(s, o)), some(new Point(17.5, 42.7)));\n\t * assert.equal(x.zipWith(none, (s, o) => new Point(s, o)), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.zip_with}\n\t */\n\tpublic zipWith<OtherValue, OtherExists extends boolean, ReturnValue>(\n\t\tother: Option<OtherValue, OtherExists>,\n\t\tf: (value0: T, value1: OtherValue) => ReturnValue\n\t): Option<ReturnValue, If<Exists, OtherExists, false>> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isSome() && other.isSome() ? some(f(this[ValueProperty], other[ValueProperty])) : none;\n\t}\n\n\t/**\n\t * Unzips an option containing a tuple of two options.\n\t *\n\t * If self is `Some([a, b])` this method returns `[Some(a), Some(b)]`. Otherwise, `[None, None]` is returned.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<[number, string]> = some([1, 'hi']);\n\t * assert.equal(x.unzip(), [some(1), some('hi')]);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<[number, string]> = none;\n\t * assert.equal(x.unzip(), [none, none]);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unzip}\n\t */\n\tpublic unzip<Value0, Value1, Exists extends boolean>(\n\t\tthis: Option<readonly [Value0, Value1], Exists>\n\t): [Option<Value0, Exists>, Option<Value1, Exists>] {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.match({\n\t\t\tsome: ([value0, value1]) => [some(value0), some(value1)],\n\t\t\tnone: () => [none, none]\n\t\t});\n\t}\n\n\t/**\n\t * Transposes an `Option` of a `Result` into a `Result` of an `Option`.\n\t *\n\t * `none` will be mapped to `ok(none)`. `some(ok(v))` and `some(err(e))` will be mapped to `ok(some(v))` and `err(e)`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<Result<number, Error>> = some(ok(5));\n\t * const y: Result<Option<number>, Error> = ok(some(5));\n\t * assert.equal(x.transpose(), y);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.transpose}\n\t */\n\tpublic transpose<ResultValue, ResultError, ResultSuccess extends boolean, Exists extends boolean>(\n\t\tthis: Option<Result<ResultValue, ResultError, ResultSuccess>, Exists>\n\t): If<Exists, Result<Some<ResultValue>, ResultError, ResultSuccess>, Ok<None>> {\n\t\treturn this.match<Result<Some<ResultValue>, ResultError, ResultSuccess>, Ok<None>>({\n\t\t\tsome: (result) => result.map(some),\n\t\t\tnone: () => ok(none)\n\t\t});\n\t}\n\n\t/**\n\t * Converts from `Result<Result<T, E>, E>` to `Result<T, E>`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<Option<number>> = some(some(6));\n\t * assert.equal(x.flatten(), some(6));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<Option<number>> = some(none);\n\t * assert.equal(x.flatten(), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<Option<number>> = none;\n\t * assert.equal(x.flatten(), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.flatten}\n\t */\n\tpublic flatten<InnerOption extends AnyOption, Exists extends boolean>(this: Option<InnerOption, Exists>): If<Exists, InnerOption, None> {\n\t\treturn this.match({ some: (inner) => inner, none: returnThis });\n\t}\n\n\t/**\n\t * Returns a `Promise` object with the awaited value (if `Some`).\n\t *\n\t * @example\n\t * ```typescript\n\t * let x = some(Promise.resolve(3));\n\t * assert.equal(await x.intoPromise(), some(3));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic intoPromise(): Promise<Option<Awaited<T>, Exists>> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.match({\n\t\t\tsome: async (value) => some(await value), // NOSONAR\n\t\t\tnone: () => Promise.resolve(none)\n\t\t});\n\t}\n\n\t/**\n\t * Checks whether or not `other` equals with self.\n\t * @param other The other option to compare.\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#tymethod.eq}\n\t */\n\tpublic eq<OtherValue extends T, OtherExists extends boolean>(other: Option<OtherValue, OtherExists>): this is Option<OtherValue, OtherExists> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isSome() === other.isSome() && this[ValueProperty] === other[ValueProperty];\n\t}\n\n\t/**\n\t * Checks whether or not `other` doesn't equal with self.\n\t * @param other The other option to compare.\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#method.ne}\n\t */\n\tpublic ne(other: Option<T, boolean>): boolean {\n\t\treturn !this.eq(other);\n\t}\n\n\t/**\n\t * Runs `ok` function if self is `Ok`, otherwise runs `err` function.\n\t * @param branches The branches to match.\n\t *\n\t * @example\n\t * ```typescript\n\t * const option = some(4).match({\n\t *   some: (v) => v,\n\t *   none: () => 0\n\t * });\n\t * assert.equal(option, 4);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const option = none.match({\n\t *   some: (v) => v,\n\t *   none: () => 0\n\t * });\n\t * assert.equal(option, 0);\n\t * ```\n\t */\n\tpublic match<SomeValue, NoneValue>(branches: {\n\t\tsome(this: Some<T>, value: T): SomeValue;\n\t\tnone(this: None): NoneValue;\n\t}): If<Exists, SomeValue, NoneValue> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isSome() ? branches.some.call(this, this[ValueProperty]) : branches.none.call(this);\n\t}\n\n\t/**\n\t * Returns an iterator over the possibly contained value.\n\t *\n\t * The iterator yields one value if the result is `Some`, otherwise none.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = some(7);\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Logs 7\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = none;\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link IOption.iter}\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.iter}\n\t */\n\tpublic [Symbol.iterator](): Generator<T> {\n\t\treturn this.iter();\n\t}\n\n\tpublic get [Symbol.toStringTag](): If<Exists, 'Some', 'None'> {\n\t\treturn this.match({ some: () => 'Some', none: () => 'None' });\n\t}\n\n\tpublic static readonly none = new Option<any, false>(null, false);\n\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static some<T = undefined>(this: void, value?: T): Some<T>;\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static some<T>(this: void, value: T): Some<T> {\n\t\treturn new Option<T, true>(value, true);\n\t}\n\n\t/**\n\t * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object. This override\n\t * exists to interoperate with other versions of this class, such as the one coming from another version of this\n\t * library or from a different build.\n\t *\n\t * @param instance The instance to check.\n\t * @returns Whether or not the instance is a `Option`.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Option } from '@sapphire/result';\n\t * const { some } = require('@sapphire/result');\n\t *\n\t * some(2) instanceof Option; // true\n\t * ```\n\t */\n\tpublic static [Symbol.hasInstance](instance: unknown): boolean {\n\t\treturn typeof instance === 'object' && instance !== null && ValueProperty in instance && ExistsProperty in instance;\n\t}\n\n\t/**\n\t * @deprecated Use {@link Option.isOption} instead.\n\t *\n\t * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object.\n\t *\n\t * @param instance The instance to check.\n\t * @returns true if the instance is a `Option` or a `Option`-like object, false otherwise.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Option } from '@sapphire/result';\n\t * const { some } = require('@sapphire/result');\n\t *\n\t * Option.isOption(some(2)); // true\n\t * ```\n\t */\n\tpublic static is(instance: unknown): instance is AnyOption {\n\t\treturn Option[Symbol.hasInstance](instance);\n\t}\n\n\t/**\n\t * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object.\n\t *\n\t * @param instance The instance to check.\n\t * @returns true if the instance is a `Option` or a `Option`-like object, false otherwise.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Option } from '@sapphire/result';\n\t * const { some } = require('@sapphire/result');\n\t *\n\t * Option.isOption(some(2)); // true\n\t * ```\n\t */\n\tpublic static isOption(instance: unknown): instance is AnyOption {\n\t\treturn Option[Symbol.hasInstance](instance);\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a callback.\n\t *\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static from<T>(this: void, op: OptionResolvable<T> | (() => OptionResolvable<T>)): Option<T> {\n\t\ttry {\n\t\t\treturn resolve(isFunction(op) ? op() : op);\n\t\t} catch {\n\t\t\treturn none;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a promise or async callback.\n\t *\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static async fromAsync<T>(this: void, op: Awaitable<OptionResolvable<T>> | (() => Awaitable<OptionResolvable<T>>)): Promise<Option<T>> {\n\t\ttry {\n\t\t\treturn resolve(await (isFunction(op) ? op() : op));\n\t\t} catch {\n\t\t\treturn none;\n\t\t}\n\t}\n\n\t/**\n\t * Creates an {@link Ok} that is the combination of all collected {@link Ok} values as an array, or the first\n\t * {@link Err} encountered.\n\t *\n\t * @param results An array of {@link Result}s.\n\t * @returns A new {@link Result}.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static all<const Entries extends readonly AnyOption[]>(this: void, results: Entries): Option<UnwrapSomeArray<Entries>> {\n\t\tconst values: unknown[] = [];\n\t\tfor (const result of results) {\n\t\t\tif (result.isNone()) return result;\n\n\t\t\tvalues.push(result[ValueProperty]);\n\t\t}\n\n\t\treturn some(values as UnwrapSomeArray<Entries>);\n\t}\n\n\t/**\n\t * Returns the first encountered {@link Some}, or a {@link None} if none was found.\n\t *\n\t * @param options An array of {@link Option}s.\n\t * @returns A new {@link Option}.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static any<const Entries extends readonly AnyOption[]>(this: void, results: Entries): Option<UnwrapSome<Entries[number]>> {\n\t\tfor (const result of results) {\n\t\t\tif (result.isSome()) return result;\n\t\t}\n\n\t\treturn none;\n\t}\n}\n\nexport namespace Option {\n\texport type Some<T> = Option<T, true>;\n\texport type None<T = any> = Option<T, false>;\n\texport type Any = Option<any>;\n\texport type Resolvable<T, Exists extends boolean = boolean> = T | null | undefined | Option<T, Exists>;\n\texport type UnwrapSome<T extends AnyOption> = T extends Some<infer S> ? S : never;\n\texport type UnwrapSomeArray<T extends readonly AnyOption[] | []> = {\n\t\t-readonly [P in keyof T]: UnwrapSome<T[P]>;\n\t};\n}\n\nexport const { some, none } = Option;\n\nfunction resolve<T>(value: Option.Resolvable<T>): Option<T> {\n\tif (value === null || value === undefined) return none;\n\tif (Option.isOption(value)) return value;\n\treturn some(value);\n}\n\nexport type OptionResolvable<T, Exists extends boolean = boolean> = Option.Resolvable<T, Exists>;\n\nexport type Some<T> = Option.Some<T>;\nexport type None<T = any> = Option.None<T>;\nexport type AnyOption = Option.Any;\n\nexport type UnwrapSome<T extends AnyOption> = Option.UnwrapSome<T>;\nexport type UnwrapSomeArray<T extends readonly AnyOption[] | []> = Option.UnwrapSomeArray<T>;\n"]}